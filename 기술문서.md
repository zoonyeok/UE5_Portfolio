ìœ íŠœë¸Œ ë§í¬ : https://www.youtube.com/watch?v=XjeqVixoUc8



# ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ

# ê·¸ë¦¬ë“œ ì¸ë²¤í† ë¦¬ ìœ„ì ¯

------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ì£¼ìš” í´ë˜ìŠ¤ êµ¬ì¡°**

#### **UZInventoryGridWidget (ì¸ë²¤í† ë¦¬ ê·¸ë¦¬ë“œ ìœ„ì ¯)**

- **ì—­í• :** ì¸ë²¤í† ë¦¬ì˜ ê²©ì(Grid)ë¥¼ ìƒì„±í•˜ê³  ì•„ì´í…œì„ ë°°ì¹˜/ê°±ì‹ í•˜ëŠ” ì—­í• 
- ì£¼ìš” êµ¬ì„± ìš”ì†Œ:
  - `GridBorder`: ì¸ë²¤í† ë¦¬ UIì˜ í…Œë‘ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” Border ìœ„ì ¯
  - `GridCanvasPanel`: ì•„ì´í…œ ìœ„ì ¯ì„ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ” íŒ¨ë„
  - `InventoryComponent`: ì‹¤ì œ ì¸ë²¤í† ë¦¬ ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ëŠ” ì»´í¬ë„ŒíŠ¸
  - `TileSize`: ê·¸ë¦¬ë“œì˜ í•œ ì¹¸ í¬ê¸°
  - `GridLines`: ê²©ìì„ ì„ ê·¸ë¦¬ê¸° ìœ„í•œ ë°ì´í„°
  - `InventoryItemWidgetMap`: í˜„ì¬ ì¸ë²¤í† ë¦¬ì— ë°°ì¹˜ëœ ì•„ì´í…œì˜ ìœ„ì ¯ì„ ê´€ë¦¬í•˜ëŠ” ë§µ
  - `bIsHighlighted`: ì•„ì´í…œ ë“œë¡­ ìœ„ì¹˜ë¥¼ ê°•ì¡° í‘œì‹œí• ì§€ ì—¬ë¶€

#### **UZInventoryItemWidget (ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ìœ„ì ¯)**

- **ì—­í• :** ì¸ë²¤í† ë¦¬ ë‚´ ì•„ì´í…œì„ UIë¡œ í‘œì‹œí•˜ê³ , ë“œë˜ê·¸ & ë“œë¡­ ê¸°ëŠ¥ì„ ì œê³µ
- ì£¼ìš” êµ¬ì„± ìš”ì†Œ:
  - `InventoryItem`: í•´ë‹¹ ìœ„ì ¯ì´ ë‚˜íƒ€ë‚´ëŠ” ì‹¤ì œ ì•„ì´í…œ ê°ì²´
  - `GridWidget`: ì´ ìœ„ì ¯ì´ ì†í•œ ì¸ë²¤í† ë¦¬ ê·¸ë¦¬ë“œ ìœ„ì ¯
  - `TileSize`: í•œ íƒ€ì¼ í¬ê¸° (í”½ì…€ ë‹¨ìœ„)
  - `BackgroundSizeBox`: ì•„ì´í…œ í¬ê¸° ì¡°ì •ì„ ìœ„í•œ UI ìš”ì†Œ
  - `ItemImage`: ì•„ì´í…œì˜ ì‹¤ì œ ì´ë¯¸ì§€
  - `bIsDragging`: í˜„ì¬ ë“œë˜ê·¸ ì¤‘ì¸ì§€ ì—¬ë¶€
  - `bToggleDragging`: í† ê¸€ ë“œë˜ê·¸ ê¸°ëŠ¥ í™œì„±í™” ì—¬ë¶€
  - `DragThreshold`: ë“œë˜ê·¸ë¡œ ì¸ì‹ë˜ëŠ” ìµœì†Œ ë§ˆìš°ìŠ¤ ì´ë™ ê±°ë¦¬

------

## **2. í•µì‹¬ ê¸°ëŠ¥ ë° êµ¬í˜„ (Core Features & Implementation)**

### **1) UZInventoryGridWidget (ì¸ë²¤í† ë¦¬ ê·¸ë¦¬ë“œ ìœ„ì ¯)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- ê²©ì(Grid) ìƒì„± ë° ì´ˆê¸°í™”
  - `CreateLineSegments()`: íƒ€ì¼ í¬ê¸°ì™€ ì¸ë²¤í† ë¦¬ í¬ê¸°ì— ë”°ë¼ ê²©ìì„ ì„ ìƒì„±
- ì•„ì´í…œ ì¶”ê°€ ë° ë°°ì¹˜
  - `RefreshGrid()`: ì¸ë²¤í† ë¦¬ ë³€ê²½ ì‹œ ëª¨ë“  ì•„ì´í…œì„ ë‹¤ì‹œ ë°°ì¹˜
- ì•„ì´í…œ ë“œë˜ê·¸ & ë“œë¡­ ì²˜ë¦¬
  - `HandleDropItem()`: ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•˜ì—¬ ì•„ì´í…œì´ ê²©ì ë‚´ ì ì ˆí•œ ìœ„ì¹˜ì— ë°°ì¹˜ë˜ë„ë¡ ì²˜ë¦¬
  - `HandleSwap()`: ì´ë¯¸ ë‹¤ë¥¸ ì•„ì´í…œì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° ìŠ¤ì™‘ ê¸°ëŠ¥ êµ¬í˜„
  - `HandleAddItem()`: ë¹ˆ ê³µê°„ì— ìƒˆë¡œìš´ ì•„ì´í…œ ì¶”ê°€
  - `HandleOutOfBoundsDrop()`: ì•„ì´í…œì´ ì¸ë²¤í† ë¦¬ ì˜ì—­ì„ ë²—ì–´ë‚˜ë©´ ì‚­ì œ í›„ ì›”ë“œì— ìŠ¤í°
- ë“œë˜ê·¸ ì‹œ ì˜ˆìƒ ìœ„ì¹˜ í‘œì‹œ
  - `SetTileColorInGrid()`: ì•„ì´í…œì´ ë“œë¡­ë  ìœ„ì¹˜ë¥¼ ê°•ì¡° í‘œì‹œ

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. ê²©ì(Grid) ì„ ì„ íš¨ìœ¨ì ìœ¼ë¡œ ë Œë”ë§í•˜ëŠ” ë°©ë²•
   - `CreateLineSegments()`ì—ì„œ ê²©ìì„ ì„ ë¯¸ë¦¬ ê³„ì‚°í•´ë‘ê³  `NativePaint()`ì—ì„œ í•œ ë²ˆë§Œ ê·¸ë¦¬ë„ë¡ ìµœì í™”
2. ì•„ì´í…œ ë°°ì¹˜ ì‹œ ìœ„ì¹˜ ê³„ì‚° ì •í™•ë„ í–¥ìƒ
   - `CalculateDropPosition()`ì„ í†µí•´ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ íƒ€ì¼ ê¸°ì¤€ìœ¼ë¡œ ë³´ì •
   - ì•„ì´í…œ í¬ê¸°ë¥¼ ê³ ë ¤í•˜ì—¬ ì¤‘ì•™ ì •ë ¬
3. ë“œë˜ê·¸ ì¤‘ ìœ„ì¹˜ ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥
   - `SetTileColorInGrid()`ì—ì„œ íƒ€ì¼ ìœ„ì¹˜ë¥¼ ë¯¸ë¦¬ ê³„ì‚°í•˜ì—¬ ê°•ì¡° í‘œì‹œ

------

### **2) UZInventoryItemWidget (ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ìœ„ì ¯)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- **ë“œë˜ê·¸ & ë“œë¡­ ê¸°ëŠ¥**
  - `NativeOnMouseButtonDown()`: ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ ë“œë˜ê·¸ ì—¬ë¶€ íŒë³„
  - `NativeOnMouseButtonUp()`: í´ë¦­ í•´ì œ ì‹œ ë“œë˜ê·¸ ì¢…ë£Œ
  - `StartDragging()`: ì‹¤ì œ ë“œë˜ê·¸ ì‹œì‘ ì²˜ë¦¬
  - `StopDragging()`: ë“œë˜ê·¸ ì¢…ë£Œ í›„ ì•„ì´í…œì´ ë“œë¡­ë  ìœ„ì¹˜ íŒë‹¨
  - `UpdateDragPosition()`: ë“œë˜ê·¸ ì¤‘ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ UI ì—…ë°ì´íŠ¸
- **ì•„ì´í…œ UI ê°±ì‹ **
  - `Refresh()`: ì•„ì´í…œ í¬ê¸° ë° ì´ë¯¸ì§€ ì„¤ì •
  - `SetItemBackgroundColor()`: ì•„ì´í…œ ë°°ê²½ìƒ‰ ì„¤ì •

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. ë“œë˜ê·¸ ì‹œ UI ê°±ì‹  ë¬¸ì œ
   - `StartDragging()`ì—ì„œ `RemoveFromParent()` í›„ `AddToViewport()`ë¡œ í•´ê²°
2. ì•„ì´í…œ ìœ„ì¹˜ ë³´ì •
   - `CalculateDropPosition()`ì„ í™œìš©í•˜ì—¬ ì¤‘ì•™ ì •ë ¬ ë° ê²¹ì¹˜ëŠ” ê²½ìš° ì²˜ë¦¬
3. ì•„ì´í…œ ë“œë¡­ ìœ„ì¹˜ ê°•ì¡°
   - `NativeOnDragOver()`ì—ì„œ ì˜ˆìƒ íƒ€ì¼ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•˜ì—¬ `GridWidget->SetTileColorInGrid()`ë¡œ ìƒ‰ìƒ ë³€ê²½

------

## **3. ì½”ë“œ ì˜ˆì œ ë° ì„¤ëª… (Code & Explanation)**

### **1) ê²©ì(Grid) ìƒì„± ë° ë Œë”ë§**

```cpp
void UZInventoryGridWidget::CreateLineSegments()
{
    if (!IsValid(InventoryComponent)) return;

    int ColumnSize = InventoryComponent.Get()->GetGridSize().Y;
    int RowSize = InventoryComponent.Get()->GetGridSize().X;

    GridLines.Reserve(ColumnSize + RowSize);

    // Vertical Lines
    for (int i = 0; i <= RowSize; i++)
    {
        float X = i * TileSize;
        GridLines.Emplace(FLine(X, 0, X, ColumnSize * TileSize));
    }

    // Horizontal Lines
    for (int i = 0; i <= ColumnSize; i++)
    {
        float Y = i * TileSize;
        GridLines.Emplace(FLine(0, Y, RowSize * TileSize, Y));
    }
}
```

- ì„¤ëª…:
  - ì¸ë²¤í† ë¦¬ í¬ê¸°ì™€ íƒ€ì¼ í¬ê¸°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ **ê°€ë¡œ ë° ì„¸ë¡œì„ **ì„ ìƒì„±
  - `GridLines`ì— `FLine` ê°ì²´ë¥¼ ì €ì¥í•´ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬

------

### **2) ì•„ì´í…œ ë“œë˜ê·¸ & ë“œë¡­ ì²˜ë¦¬**

```cpp
void UZInventoryItemWidget::StartDragging(const FVector2D& MousePosition)
{
    bIsDragging = true;

    this->RemoveFromParent();
    this->SetDesiredSizeInViewport(this->GetDesiredSize());

    FVector2D AdjustedPosition = MousePosition - (this->GetDesiredSize() * 0.5f);
    this->SetPositionInViewport(AdjustedPosition, true);
    this->AddToViewport();
}
```

- ì„¤ëª…:
  - ì•„ì´í…œì„ ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•  ë•Œ, ê¸°ì¡´ ë¶€ëª¨ UIì—ì„œ ì œê±° í›„ ìƒˆë¡œìš´ Viewport ìœ„ì¹˜ì— ë°°ì¹˜
  - `SetDesiredSizeInViewport()`ë¥¼ í†µí•´ UI í¬ê¸° ìœ ì§€
  - `SetPositionInViewport()`ë¡œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ì•™ ì •ë ¬

------

### **3) ì•„ì´í…œ ë°°ì¹˜ & ìŠ¤ì™‘ ê¸°ëŠ¥**

```cpp
void UZInventoryGridWidget::HandleSwap(UZInventoryItemWidget* DroppedWidget, TObjectPtr<UZInventoryItem> DroppedItem, 
    const FVector2D& InMousePosition, const FIntPoint& ItemDropPos)
{
    TObjectPtr<UZInventoryItem> ItemInGrid = InventoryComponent->GetItemAtPosition(DroppedItem, ItemDropPos, DroppedItem->GetGridSize());
    if (!ItemInGrid) return;

    FIntPoint FoundItemPos = InventoryComponent->FindItemPosition(ItemInGrid);
    UZInventoryItemWidget* WidgetInGrid = InventoryItemWidgetMap.FindRef(FoundItemPos);
    if (!WidgetInGrid) return;

    InventoryComponent->SwapItems(ItemInGrid, DroppedItem, ItemDropPos);

    if (DroppedWidget->IsInViewport())
    {
        DroppedWidget->RemoveFromParent();
    }

    if (UCanvasPanelSlot* GridPanel = Cast<UCanvasPanelSlot>(GridCanvasPanel->AddChild(DroppedWidget)))
    {
        GridPanel->SetAutoSize(true);
        GridPanel->SetPosition(ItemDropPos * TileSize);
    }

    WidgetInGrid->StartDragging(InMousePosition);

    FIntPoint PrevItemPosition = InventoryComponent->FindItemPosition(DroppedItem);
    UpdateInventoryItemWidgetMap(DroppedWidget, PrevItemPosition, ItemDropPos);

    RefreshGrid();
}
```

- ì„¤ëª…:
  - ê¸°ì¡´ ìœ„ì¹˜ì— ì•„ì´í…œì´ ìˆë‹¤ë©´, ìƒˆë¡œìš´ ì•„ì´í…œê³¼ ìŠ¤ì™‘
  - UI ìœ„ì¹˜ ê°±ì‹  í›„ `RefreshGrid()` í˜¸ì¶œí•˜ì—¬ UI ì—…ë°ì´íŠ¸

------

## **ê²°ë¡ **

ì´ ì‹œìŠ¤í…œì€ **ê²©ì(Grid) ê¸°ë°˜ì˜ ì¸ë²¤í† ë¦¬**ë¥¼ ì§€ì›í•˜ë©°, **ì•„ì´í…œ ë“œë˜ê·¸ & ë“œë¡­, ìœ„ì¹˜ ë³´ì •, ìŠ¤ì™‘ ê¸°ëŠ¥** ë“±ì„ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
 íŠ¹íˆ, **ìœ„ì¹˜ ê³„ì‚° ì •í™•ì„±, ë“œë˜ê·¸ ì¤‘ UI ê°±ì‹ , ì˜ˆìƒ íƒ€ì¼ í•˜ì´ë¼ì´íŠ¸ í‘œì‹œ** ë“±ì´ ì£¼ìš” êµ¬í˜„ ë‚œì œì˜€ìœ¼ë©°, ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì—¬ëŸ¬ ë³´ì • ë¡œì§ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.





# ì•„ì´í…œ ìŠ¬ë¡¯ ìœ„ì ¯



------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ì£¼ìš” í´ë˜ìŠ¤ êµ¬ì¡°**

#### **UZEquipmentSlotWidget (ì¥ë¹„ ìŠ¬ë¡¯ ìœ„ì ¯)**

- **ì—­í• :**
  - íŠ¹ì • ìŠ¬ë¡¯(ItemSlotType)ì— ë§ëŠ” ì¥ë¹„ ì•„ì´í…œì„ ë°°ì¹˜í•˜ê³  ê´€ë¦¬í•˜ëŠ” ì—­í• 
  - `UZInventoryItemWidget`ê³¼ ìƒí˜¸ì‘ìš©í•˜ì—¬ ë“œë˜ê·¸ ì•¤ ë“œë¡­ì„ í†µí•œ ì¥ë¹„ ì¥ì°©ì„ ì§€ì›
  - `UZEquipmentManagerComponent`ì™€ ì—°ê²°ë˜ì–´ ì‹¤ì œ ì¥ì°© ë°ì´í„°ë¥¼ ê´€ë¦¬
- **ì£¼ìš” êµ¬ì„± ìš”ì†Œ:**
  - `ItemSlotType`: í˜„ì¬ ìŠ¬ë¡¯ì´ ì–´ë–¤ ì•„ì´í…œ ìœ í˜•(ë¬´ê¸°, ë°©ì–´êµ¬ ë“±)ì„ ìˆ˜ìš©í•  ìˆ˜ ìˆëŠ”ì§€ ì €ì¥
  - `EquipmentManagerComponent`: ì‹¤ì œ ì¥ë¹„ ë°ì´í„° ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ì»´í¬ë„ŒíŠ¸
  - `SlotCanvasPanel`: ì¥ë¹„ ìŠ¬ë¡¯ ë‚´ì—ì„œ ì•„ì´í…œì„ í‘œì‹œí•˜ëŠ” UI íŒ¨ë„
  - `SpacialInventoryComponent`: ì¸ë²¤í† ë¦¬ì—ì„œ ì•„ì´í…œì„ ì œê±°í•˜ê±°ë‚˜ ì¶”ê°€í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì¸ë²¤í† ë¦¬ ì»´í¬ë„ŒíŠ¸
  - `Item`: í˜„ì¬ ì¥ì°©ëœ ì•„ì´í…œ

------

## **2. í•µì‹¬ ê¸°ëŠ¥ ë° êµ¬í˜„ (Core Features & Implementation)**

### **1) UZEquipmentSlotWidget (ì¥ë¹„ ìŠ¬ë¡¯ ìœ„ì ¯)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- ì´ˆê¸°í™” ë° ì¥ë¹„ ìŠ¬ë¡¯ ìœ í˜• ì„¤ì •
  - `InitializeEquipWidget()`: íŠ¹ì • ìŠ¬ë¡¯(ItemSlotType)ì— ëŒ€í•œ ì •ë³´ ë° ì¸ë²¤í† ë¦¬ ì»´í¬ë„ŒíŠ¸ ì°¸ì¡° ì €ì¥
- ì•„ì´í…œ ë“œë˜ê·¸ & ë“œë¡­ ê¸°ëŠ¥
  - `HandleDropItem()`: ì¸ë²¤í† ë¦¬ ì•„ì´í…œì„ í•´ë‹¹ ìŠ¬ë¡¯ìœ¼ë¡œ ë“œë¡­í•  ë•Œ ì²˜ë¦¬í•˜ëŠ” ë¡œì§
  - `RefreshGrid()`: ì¥ë¹„ UIë¥¼ ê°±ì‹ í•˜ëŠ” ê¸°ëŠ¥ (í˜„ì¬ êµ¬í˜„ í•„ìš”)

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. ì•„ì´í…œ ë“œë¡­ ì‹œ í•´ë‹¹ ìŠ¬ë¡¯ê³¼ í˜¸í™˜ë˜ëŠ”ì§€ íŒë³„í•˜ëŠ” ë¬¸ì œ
   - `ItemSlotType`ê³¼ ë“œë¡­ëœ ì•„ì´í…œì˜ `ItemSlotType`ì„ ë¹„êµí•˜ì—¬ ìœ íš¨í•œ ê²½ìš°ì—ë§Œ ì¥ì°© í—ˆìš©
2. ë“œë˜ê·¸ ì•¤ ë“œë¡­ í›„ ê¸°ì¡´ ì¸ë²¤í† ë¦¬ì—ì„œ ì•„ì´í…œì„ ì‚­ì œí•˜ëŠ” ê³¼ì •
   - `SpacialInventoryComponent->RemoveItemByPointer(InventoryItem)`ì„ í˜¸ì¶œí•˜ì—¬ ì¸ë²¤í† ë¦¬ì—ì„œ ì œê±°
3. UI ì—…ë°ì´íŠ¸ ë¬¸ì œ
   - `UCanvasPanelSlot`ì„ í™œìš©í•˜ì—¬ `SlotCanvasPanel` ë‚´ì—ì„œ ìœ„ì¹˜ ë° í¬ê¸°ë¥¼ ì¡°ì •

------

## **3. ì½”ë“œ ì˜ˆì œ ë° ì„¤ëª… (Code & Explanation)**

### **1) ì¥ë¹„ ìŠ¬ë¡¯ ì´ˆê¸°í™”**

```cpp
void UZEquipmentSlotWidget::InitializeEquipWidget(const TObjectPtr<UZEquipmentManagerComponent>& InEquipmentManagerComponent,
                                             const TObjectPtr<UZInventoryItem>& InventoryItem)
{
	if (InventoryItem)
	{
		if (FItemStaticData* ItemData = InventoryItem.Get()->GetStaticData())
		{
			ItemSlotType = ItemData->ItemSlotType; // ì•„ì´í…œ ìŠ¬ë¡¯ ìœ í˜• ì €ì¥
		}
	}

	// í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ìºë¦­í„°ì˜ ì¸ë²¤í† ë¦¬ ì»´í¬ë„ŒíŠ¸ ê°€ì ¸ì˜¤ê¸°
	if (APlayerController* Controller = Cast<AZPlayerController>(GetOwningPlayer()))
	{
		if (AZ1Character* Character = Cast<AZ1Character>(Controller->GetCharacter()))
		{
			SpacialnventoryComponent = Character->GetComponentByClass<UZSpatialInventoryComponent>();
		}
	}

	EquipmentManagerComponent = InEquipmentManagerComponent;
}
```

- ì„¤ëª…:
  - `InventoryItem`ì„ ê¸°ë°˜ìœ¼ë¡œ **í•´ë‹¹ ìŠ¬ë¡¯ì´ ì–´ë–¤ ì•„ì´í…œì„ ìˆ˜ìš©í•˜ëŠ”ì§€(ItemSlotType) ê²°ì •**
  - `APlayerController`ì—ì„œ `AZ1Character`ì˜ `UZSpatialInventoryComponent`ë¥¼ ì°¾ì•„ **ì¸ë²¤í† ë¦¬ ì°¸ì¡° ì €ì¥**
  - `EquipmentManagerComponent` ì°¸ì¡° ì„¤ì •

------

### **2) ì•„ì´í…œ ë“œë¡­ ì²˜ë¦¬**

```cpp
bool UZEquipmentSlotWidget::HandleDropItem(UZInventoryItemWidget* DroppedWidget, const FVector2D& InMousePosition)
{
	FGeometry EquipmentGeometry = GetCachedGeometry();
	if (!EquipmentGeometry.IsUnderLocation(InMousePosition))
	{
		UE_LOG(LogTemp, Warning, TEXT("Mouse is not over EquipmentGridWidget!"));
		return false;
	}

	if (TObjectPtr<UZInventoryItem> InventoryItem = DroppedWidget->GetInventoryItem())
	{
		if (FItemStaticData* ItemData = InventoryItem->GetStaticData())
		{
			EItemSlotType WidgetItemSlotType = ItemData->ItemSlotType;

			// ìŠ¬ë¡¯ íƒ€ì…ì´ ë§ì§€ ì•Šìœ¼ë©´ ë¦¬í„´
			if (ItemSlotType != WidgetItemSlotType)
			{
				return false;
			}

			// ì¥ì°© ì„±ê³µ ì‹œ UI ê°±ì‹ 
			if (EquipmentManagerComponent->EquipItem(WidgetItemSlotType, InventoryItem))
			{
				if (UCanvasPanelSlot* SlotPanel = Cast<UCanvasPanelSlot>(SlotCanvasPanel.Get()->AddChild(DroppedWidget)))
				{
					SlotPanel->SetAutoSize(true);
					SlotPanel->SetPosition(FVector2D::ZeroVector);
				}

				Item = InventoryItem;
				DroppedWidget->SetParentWidget(this);
				SpacialnventoryComponent->RemoveItemByPointer(InventoryItem);
				return true;
			}
		}
	}

	return false;
}
```

- ì„¤ëª…:
  1. `FGeometry::IsUnderLocation(InMousePosition)`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§ˆìš°ìŠ¤ê°€ ì¥ë¹„ ìŠ¬ë¡¯ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
  2. ë“œë¡­ëœ ì•„ì´í…œì˜ `ItemSlotType`ì„ ê°€ì ¸ì™€ í˜„ì¬ ìŠ¬ë¡¯(`ItemSlotType`)ê³¼ ë¹„êµ
  3. `EquipmentManagerComponent->EquipItem()`ì„ í˜¸ì¶œí•˜ì—¬ ì‹¤ì œ ì¥ë¹„ ì¥ì°© ì‹œë„
  4. ì¥ì°© ì„±ê³µí•˜ë©´:
     - UIì—ì„œ í•´ë‹¹ ì•„ì´í…œì„ `SlotCanvasPanel`ì— ë°°ì¹˜
     - `SpacialInventoryComponent->RemoveItemByPointer()` í˜¸ì¶œí•˜ì—¬ ì¸ë²¤í† ë¦¬ì—ì„œ ì œê±°

------

## **4. ê²°ë¡ **

ì´ ì‹œìŠ¤í…œì€ **ì¥ë¹„ ì¥ì°© UI ë° ì¸ë²¤í† ë¦¬ ì—°ë™**ì„ ë‹´ë‹¹í•˜ëŠ” ì—­í• ì„ í•˜ë©°,
 **ë“œë˜ê·¸ ì•¤ ë“œë¡­ì„ í†µí•´ ì•„ì´í…œì„ íŠ¹ì • ìŠ¬ë¡¯ì— ë°°ì¹˜**í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.

### **ğŸ”‘ ì£¼ìš” ì„¤ê³„ í¬ì¸íŠ¸**

- **ì¥ë¹„ ìŠ¬ë¡¯ ìœ í˜• ê²€ì¦:** ë“œë¡­ëœ ì•„ì´í…œì´ í˜„ì¬ ìŠ¬ë¡¯ê³¼ ë§ëŠ”ì§€ ê²€ì‚¬ (`ItemSlotType`)
- **ì•„ì´í…œ UI ê´€ë¦¬:** ì¥ë¹„ ì¥ì°© í›„ `SlotCanvasPanel`ì— ì¶”ê°€
- **ì¸ë²¤í† ë¦¬ ë°ì´í„°ì™€ ë™ê¸°í™”:** ì¥ë¹„ ì¥ì°© ì‹œ ì¸ë²¤í† ë¦¬ì—ì„œ ì•„ì´í…œ ì œê±°

**ì¶”ê°€ êµ¬í˜„ í•„ìš”:**

- `RefreshGrid()` ë©”ì„œë“œì—ì„œ ì¥ì°©ëœ ì•„ì´í…œì´ ë³€ê²½ë  ë•Œ UIë¥¼ ê°±ì‹ í•˜ëŠ” ë¡œì§ ì¶”ê°€ í•„ìš”
- `HandleDropItem()`ì—ì„œ ë“œë¡­ ì‹¤íŒ¨ ì‹œ í”¼ë“œë°± ì œê³µ (ì• ë‹ˆë©”ì´ì…˜ ë˜ëŠ” ì‚¬ìš´ë“œ)



# Item ì„¤ê³„



## **UZWorldItem, UZInventoryItem, AZPotionWorldItem, UZPotionInventoryItem ì•„í‚¤í…ì²˜ ë° êµ¬í˜„ ì •ë¦¬**

------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ì£¼ìš” í´ë˜ìŠ¤ êµ¬ì¡°**

#### **AZWorldItem (ì›”ë“œ ì•„ì´í…œ)**

- **ì—­í• :**
  - ì›”ë“œì— ì¡´ì¬í•˜ëŠ” ì•„ì´í…œì„ ë‚˜íƒ€ë‚´ëŠ” ì•¡í„°
  - ì¸ë²¤í† ë¦¬ ì•„ì´í…œ(`UZInventoryItem`)ìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥
  - í”½ì—… ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸(ì¶©ëŒ ë° UI ìš”ì†Œ í¬í•¨)
- **ì£¼ìš” êµ¬ì„± ìš”ì†Œ:**
  - `StaticMeshComponent`: ì•„ì´í…œì´ ì›”ë“œì—ì„œ ë³´ì´ëŠ” 3D ëª¨ë¸ (ì„ íƒì )
  - `SkeletalMeshComponent`: ë§Œì•½ ìŠ¤ì¼ˆë ˆí†¤ ë©”ì‹œê°€ í•„ìš”í•˜ë‹¤ë©´ ì‚¬ìš© (ì„ íƒì )
  - `WorldItemWidgetComponent`: ì›”ë“œ ì•„ì´í…œ ìœ„ì ¯ (ì´ë¦„ ë˜ëŠ” ìƒíƒœ í‘œì‹œ)
  - `ItemDataTable`: ì•„ì´í…œì˜ ê¸°ë³¸ ì •ë³´ê°€ ì €ì¥ëœ ë°ì´í„° í…Œì´ë¸”
  - `ItemID`: í•´ë‹¹ ì•„ì´í…œì„ êµ¬ë¶„í•˜ëŠ” ì‹ë³„ì

#### **UZInventoryItem (ì¸ë²¤í† ë¦¬ ì•„ì´í…œ)**

- **ì—­í• :**
  - ì¸ë²¤í† ë¦¬ ë‚´ë¶€ì—ì„œ ê´€ë¦¬ë˜ëŠ” ì•„ì´í…œ ë°ì´í„°
  - ì•„ì´í…œì˜ UI ì•„ì´ì½˜, ìŠ¤íƒ ìˆ˜ëŸ‰, ì•„ì´í…œ íš¨ê³¼ ê´€ë¦¬
- **ì£¼ìš” êµ¬ì„± ìš”ì†Œ:**
  - `ItemDataTable`: ì•„ì´í…œì˜ ê¸°ë³¸ ì •ë³´ê°€ ì €ì¥ëœ ë°ì´í„° í…Œì´ë¸”
  - `ItemRowName`: ë°ì´í„° í…Œì´ë¸”ì—ì„œ ì•„ì´í…œì„ ì°¾ê¸° ìœ„í•œ ì‹ë³„ì
  - `ItemGridSize`: ì•„ì´í…œì´ ì¸ë²¤í† ë¦¬ì—ì„œ ì°¨ì§€í•˜ëŠ” í¬ê¸°
  - `InstanceData.Quantity`: í˜„ì¬ ìŠ¤íƒ ìˆ˜ëŸ‰
  - `IconMaterial`: UIì—ì„œ ì‚¬ìš©í•  ì•„ì´í…œ ì•„ì´ì½˜
  - `bIsRotate`: ì•„ì´ì½˜ íšŒì „ ì—¬ë¶€

#### **AZPotionWorldItem (ì›”ë“œ í¬ì…˜ ì•„ì´í…œ)**

- **ì—­í• :**
  - `AZWorldItem`ì„ ìƒì†í•˜ì—¬ í¬ì…˜ ì•„ì´í…œì— íŠ¹í™”ëœ ê¸°ëŠ¥ ì¶”ê°€
  - ìºë¦­í„°ê°€ ì•„ì´í…œì„ ì£¼ì› ì„ ë•Œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ(`UZPotionInventoryItem`)ìœ¼ë¡œ ë³€í™˜
- **ì£¼ìš” êµ¬ì„± ìš”ì†Œ:**
  - `PickUp_Implementation()`: í”Œë ˆì´ì–´ê°€ ì•„ì´í…œì„ ì£¼ìš¸ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
  - `ConvertToInventoryItem()`: í¬ì…˜ì„ ì¸ë²¤í† ë¦¬ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜

#### **UZPotionInventoryItem (í¬ì…˜ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ)**

- **ì—­í• :**
  - `UZInventoryItem`ì„ ìƒì†í•˜ì—¬ í¬ì…˜ ì•„ì´í…œì— íŠ¹í™”ëœ ê¸°ëŠ¥ ì¶”ê°€
  - ì‚¬ìš© ì‹œ ìºë¦­í„°ì˜ HPë¥¼ íšŒë³µí•˜ëŠ” ê¸°ëŠ¥ êµ¬í˜„
  - ì›”ë“œì— ë“œë¡­í•  ìˆ˜ë„ ìˆìŒ
- **ì£¼ìš” êµ¬ì„± ìš”ì†Œ:**
  - `HealthAmount`: ì‚¬ìš© ì‹œ íšŒë³µí•  ì²´ë ¥ ê°’
  - `UseItem_Implementation()`: í¬ì…˜ ì‚¬ìš© ì‹œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
  - `DropItem_Implementation()`: í¬ì…˜ì„ ì›”ë“œì— ë“œë¡­í•˜ëŠ” ê¸°ëŠ¥

------

## **2. í•µì‹¬ ê¸°ëŠ¥ ë° êµ¬í˜„ (Core Features & Implementation)**

### **1) AZWorldItem (ì›”ë“œ ì•„ì´í…œ ì•¡í„°)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- ì›”ë“œì—ì„œ íŠ¹ì • ì•„ì´í…œì„ ë¡œë“œí•˜ì—¬ í‘œì‹œ
  - `InitializeItem()`: ì•„ì´í…œ IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë°ì´í„° ë¡œë“œ ë° ì„¤ì •
  - `LoadMesh()`: ë°ì´í„° í…Œì´ë¸”ì—ì„œ ë©”ì‹œë¥¼ ê°€ì ¸ì™€ ì•„ì´í…œì˜ ì™¸í˜• ì„¤ì •
- ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ë¡œ ë³€í™˜
  - `ConvertToInventoryItem()`: ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜
- ì¶©ëŒ ì²˜ë¦¬ ë° ìƒí˜¸ì‘ìš©
  - `SetCollisionInSlot()`: ì•„ì´í…œì˜ ì¶©ëŒ ì„¤ì •
  - `PickUp_Implementation()`: í”Œë ˆì´ì–´ê°€ ì•„ì´í…œì„ ì£¼ìš¸ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. ì›”ë“œì—ì„œ ì•„ì´í…œì´ ì‚¬ë¼ì§€ê³  ì¸ë²¤í† ë¦¬ì— ì¶”ê°€ë˜ëŠ” ê³¼ì •
   - `ConvertToInventoryItem()`ì„ í†µí•´ `UZInventoryItem`ì„ ìƒì„±í•˜ê³ , `Destroy()` í˜¸ì¶œ
2. ì•„ì´í…œ ë°ì´í„° ë¡œë”© ë¬¸ì œ
   - `LoadMesh()`ì—ì„œ `ItemDataTable->FindRow<FItemStaticData>()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ë¡œë“œ
3. ì•„ì´í…œì„ ìœ ë™ì ìœ¼ë¡œ ë°°ì¹˜í•˜ê¸° ìœ„í•œ ì¶©ëŒ ì²˜ë¦¬
   - `SetCollisionInSlot()`ì—ì„œ `SkeletalMeshComponent`ì™€ `StaticMeshComponent`ë¥¼ ì§€ì›í•˜ë„ë¡ êµ¬í˜„

------

### **2) UZInventoryItem (ì¸ë²¤í† ë¦¬ ì•„ì´í…œ)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- ì•„ì´í…œ ë°ì´í„° ìºì‹± ë° ë¡œë”© ìµœì í™”
  - `GetStaticData()`: ë°ì´í„° í…Œì´ë¸”ì—ì„œ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ë˜, ìºì‹±ì„ ì‚¬ìš©í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
- ì•„ì´ì½˜ ë¨¸í‹°ë¦¬ì–¼ ë™ì  ìƒì„±
  - `CreateItemIconDynamicMaterial()`: UI ì•„ì´ì½˜ì„ ë™ì ìœ¼ë¡œ ìƒì„±
- ì›”ë“œ ì•„ì´í…œ ìƒì„± ê¸°ëŠ¥
  - `SpawnWorldItem()`: ì•„ì´í…œì„ ì›”ë“œì— ìŠ¤í°

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. ì•„ì´ì½˜ ë¨¸í‹°ë¦¬ì–¼ì„ ë™ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ë¬¸ì œ
   - `CreateItemIconDynamicMaterial()`ì—ì„œ `UMaterialInstanceDynamic`ì„ ìƒì„±í•˜ì—¬ ìºì‹±
2. ë°ì´í„° ë¡œë”© ìµœì í™”
   - `bIsStaticDataCached` ë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ì—¬ `GetStaticData()`ì—ì„œ ì¤‘ë³µ ë¡œë”© ë°©ì§€
3. ì•„ì´í…œ ë“œë¡­ í›„ ì›”ë“œì— ë‹¤ì‹œ ë‚˜íƒ€ë‚˜ë„ë¡ ì²˜ë¦¬
   - `SpawnWorldItem()`ì—ì„œ `World->SpawnActor<AZWorldItem>()` í˜¸ì¶œ

------

### **3) AZPotionWorldItem (ì›”ë“œ í¬ì…˜ ì•„ì´í…œ)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- í”Œë ˆì´ì–´ê°€ í¬ì…˜ì„ ì£¼ìš¸ ìˆ˜ ìˆë„ë¡ ì²˜ë¦¬
  - `PickUp_Implementation()`: í¬ì…˜ì´ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€ë˜ë©´ ì›”ë“œì—ì„œ ì œê±°
- í¬ì…˜ì„ ì¸ë²¤í† ë¦¬ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜
  - `ConvertToInventoryItem()`: `UZPotionInventoryItem` ê°ì²´ë¡œ ë³€í™˜í•˜ì—¬ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. í¬ì…˜ ì•„ì´í…œì´ ì›”ë“œì—ì„œ ì‚¬ë¼ì§€ê³  ì¸ë²¤í† ë¦¬ì— ì¶”ê°€ë˜ëŠ” ê³¼ì •
   - `PickUp_Implementation()`ì—ì„œ `InvenComp->TryAddItem()` í˜¸ì¶œ í›„ `Destroy()`
2. í¬ì…˜ ì•„ì´í…œì„ ì˜¬ë°”ë¥´ê²Œ ë³€í™˜í•˜ëŠ” ê³¼ì •
   - `ConvertToInventoryItem()`ì—ì„œ `NewObject<UZPotionInventoryItem>()` ìƒì„± í›„ ì´ˆê¸°í™”

------

### **4) UZPotionInventoryItem (í¬ì…˜ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ)**

#### **ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥**

- ì•„ì´í…œ ì‚¬ìš© ì‹œ ì²´ë ¥ íšŒë³µ
  - `UseItem_Implementation()`: í”Œë ˆì´ì–´ê°€ ì•„ì´í…œì„ ì‚¬ìš©í•˜ë©´ ì²´ë ¥ ì¦ê°€
- í¬ì…˜ì„ ì›”ë“œì— ë“œë¡­í•  ìˆ˜ ìˆë„ë¡ ì²˜ë¦¬
  - `DropItem_Implementation()`: ì•„ì´í…œì„ ì›”ë“œì— ìŠ¤í°

#### **ğŸ”§ ë‚œì´ë„ ìˆì—ˆë˜ ë¶€ë¶„ê³¼ í•´ê²° ë°©ë²•**

1. ìºë¦­í„°ê°€ í¬ì…˜ì„ ì‚¬ìš©í•˜ë©´ ì²´ë ¥ì´ ì¦ê°€í•˜ë„ë¡ êµ¬í˜„
   - `UseItem_Implementation()`ì—ì„œ `UZAttributeComponent->ChangeCurrentHP()` í˜¸ì¶œ
2. í¬ì…˜ì„ ì›”ë“œì— ë“œë¡­í•  ë•Œ ì ì ˆí•œ ìœ„ì¹˜ë¡œ ìŠ¤í°
   - `DropItem_Implementation()`ì—ì„œ `Character->GetActorForwardVector()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìºë¦­í„° ì•ì— ìŠ¤í°
3. ìŠ¤í° ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ ì˜¤ë¥˜ ì²˜ë¦¬
   - `DropItem_Implementation()`ì—ì„œ ì‹¤íŒ¨ ì‹œ `EInventoryActionResult::ItemSpawnFail` ë°˜í™˜

------

## **3. ì½”ë“œ ì˜ˆì œ ë° ì„¤ëª… (Code & Explanation)**

### **1) ì›”ë“œ ì•„ì´í…œì—ì„œ ì¸ë²¤í† ë¦¬ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜**

```cpp
UZInventoryItem* AZWorldItem::ConvertToInventoryItem()
{
    UZInventoryItem* NewInventoryItem = NewObject<UZInventoryItem>();
    return NewInventoryItem;
}
```

- ì„¤ëª…:
  - ìƒˆë¡œìš´ `UZInventoryItem` ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ ë°˜í™˜

------

### **2) í¬ì…˜ ì‚¬ìš© ë¡œì§**

```cpp
void UZPotionInventoryItem::UseItem_Implementation(APawn* User)
{
    AZ1Character* Character = Cast<AZ1Character>(User);
    if (!IsValid(Character)) return;

    UZAttributeComponent* AttributeComp = Character->FindComponentByClass<UZAttributeComponent>();
    if (!IsValid(AttributeComp)) return;

    AttributeComp->ChangeCurrentHP(this, HealthAmount);
}
```

- ì„¤ëª…:
  - `UZAttributeComponent`ë¥¼ í†µí•´ ì²´ë ¥ ì¦ê°€

------

## **4. ê²°ë¡ **

ì´ ì‹œìŠ¤í…œì€ **ì›”ë“œ ì•„ì´í…œê³¼ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ê°„ì˜ ë³€í™˜**ì„ ê´€ë¦¬í•˜ë©°,
 **ë“œë˜ê·¸ ì•¤ ë“œë¡­, í”½ì—…, ë“œë¡­ ê¸°ëŠ¥**ì„ ëª¨ë‘ êµ¬í˜„í•˜ê³  ìˆìŠµë‹ˆë‹¤.

### **ğŸ”‘ ì£¼ìš” ì„¤ê³„ í¬ì¸íŠ¸**

- **ë°ì´í„° ìºì‹±:** `GetStaticData()`ë¥¼ í™œìš©í•œ ìµœì í™”
- **ì•„ì´ì½˜ ë™ì  ìƒì„±:** `CreateItemIconDynamicMaterial()`
- **ì²´ë ¥ íšŒë³µ ê¸°ëŠ¥:** `UseItem_Implementation()`
- **ì›”ë“œ ì•„ì´í…œ ìŠ¤í°:** `SpawnWorldItem()` ë° `DropItem_Implementation()`

ì´ì œ **UI ë° ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™”**ê¹Œì§€ í™•ì¥í•˜ë©´ ë”ìš± ì™„ì„±ë„ ë†’ì€ ì‹œìŠ¤í…œì´ ë  ê²ƒì…ë‹ˆë‹¤.



# **ë¬´ê¸° ì‹œìŠ¤í…œ ë° ì¸í„°í˜ì´ìŠ¤ ì •ë¦¬**

------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ì£¼ìš” í´ë˜ìŠ¤ êµ¬ì¡°**

#### **ì¸í„°í˜ì´ìŠ¤ (ZDropable, ZInteractable, ZPickable, ZUseable)**

ê° ì¸í„°í˜ì´ìŠ¤ëŠ” íŠ¹ì • ê¸°ëŠ¥ì„ ê°€ì§€ëŠ” ì•¡í„°(AActor) ë˜ëŠ” ì˜¤ë¸Œì íŠ¸(UObject)ì— ê³µí†µì ìœ¼ë¡œ ì ìš©ë  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ë¨.

| ì¸í„°í˜ì´ìŠ¤       | ì„¤ëª…                                             |
| ---------------- | ------------------------------------------------ |
| `IZDropable`     | ì•„ì´í…œì„ ë“œë¡­í•  ìˆ˜ ìˆëŠ” ì¸í„°í˜ì´ìŠ¤               |
| `IZInteractable` | ìƒí˜¸ì‘ìš© ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤       |
| `IZPickable`     | ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ê°ì²´ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ |
| `IZUseable`      | ì‚¬ìš© ê°€ëŠ¥í•œ ì•„ì´í…œì„ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤             |

#### **ë¬´ê¸° í´ë˜ìŠ¤ (ZBaseWeapon, ZMeleeWeaponBase, ZRangedWeaponBase)**

ê° ë¬´ê¸° í´ë˜ìŠ¤ëŠ” `ZBaseWeapon`ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ë¬´ê¸° íƒ€ì…ë³„ë¡œ ì„¸ë¶„í™”ë¨.

| í´ë˜ìŠ¤               | ì„¤ëª…                    |
| -------------------- | ----------------------- |
| `AZBaseWeapon`       | ëª¨ë“  ë¬´ê¸°ì˜ ê¸°ë³¸ í´ë˜ìŠ¤ |
| `AZMeleeWeaponBase`  | ê·¼ì ‘ ë¬´ê¸° (ê²€, ë„ë¼ ë“±) |
| `AZRangedWeaponBase` | ì›ê±°ë¦¬ ë¬´ê¸° (ì´ê¸°ë¥˜)    |

------

## **2. ì¸í„°í˜ì´ìŠ¤ (Interfaces)**

### **1) ZDropable (ë“œë¡­ ê°€ëŠ¥)**

```cpp
UINTERFACE(MinimalAPI)
class UZDropable : public UInterface
{
	GENERATED_BODY()
};

class Z1_API IZDropable
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Drop")
	EInventoryActionResult DropItem(APawn* Dropper);
};
```

- **ì„¤ëª…:** ì•„ì´í…œì„ ë“œë¡­í•  ìˆ˜ ìˆë„ë¡ í•¨.
- **ì‚¬ìš© í´ë˜ìŠ¤:** `UZInventoryItem`, `AZBaseWeapon`

------

### **2) ZInteractable (ìƒí˜¸ì‘ìš© ê°€ëŠ¥)**

```cpp
UINTERFACE(MinimalAPI)
class UZInteractable : public UInterface
{
	GENERATED_BODY()
};

class Z1_API IZInteractable
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Interact")
	void Interact(AActor* Interactor);
};
```

- **ì„¤ëª…:** í”Œë ˆì´ì–´ ë˜ëŠ” AIê°€ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ì˜¤ë¸Œì íŠ¸ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤.
- **ì‚¬ìš© í´ë˜ìŠ¤:** `AZWorldItem`, `AZBaseWeapon`

------

### **3) ZPickable (í”½ì—… ê°€ëŠ¥)**

```cpp
UINTERFACE(MinimalAPI)
class UZPickable : public UInterface
{
	GENERATED_BODY()
};

class Z1_API IZPickable
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Pickup")
	EInventoryActionResult PickUp(APawn* Picker);
};
```

- **ì„¤ëª…:** ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€í•  ìˆ˜ ìˆë„ë¡ í•¨.
- **ì‚¬ìš© í´ë˜ìŠ¤:** `AZWorldItem`, `AZBaseWeapon`

------

### **4) ZUseable (ì‚¬ìš© ê°€ëŠ¥)**

```cpp
UINTERFACE(MinimalAPI)
class UZUseable : public UInterface
{
	GENERATED_BODY()
};

class Z1_API IZUseable
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Use")
	void UseItem(APawn* User);
};
```

- **ì„¤ëª…:** ì‚¬ìš© ê°€ëŠ¥í•œ ì•„ì´í…œì„ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ (ì˜ˆ: í¬ì…˜, ì¥ë¹„).
- **ì‚¬ìš© í´ë˜ìŠ¤:** `UZInventoryItem`, `AZBaseWeapon`

------

## **3. ë¬´ê¸° ì‹œìŠ¤í…œ (Weapon System)**

### **1) ZBaseWeapon (ë¬´ê¸° ê¸°ë³¸ í´ë˜ìŠ¤)**

```cpp
class Z1_API AZBaseWeapon : public AActor, public IZPickable, public IZDropable
{
	GENERATED_BODY()

public:
	AZBaseWeapon();

	virtual void StartAttack();
	virtual void EndAttack();
	virtual float CalculateFinalDamage();

	// í”½ì—… (ì¸ë²¤í† ë¦¬ë¡œ ì´ë™)
	virtual EInventoryActionResult PickUp_Implementation(APawn* Player) override;

	// ì¸ë²¤í† ë¦¬ ì•„ì´í…œìœ¼ë¡œ ë³€í™˜
	virtual UZInventoryItem* ConvertToInventoryItem();
};
```

- **ì„¤ëª…:** ëª¨ë“  ë¬´ê¸°ì˜ ê¸°ë³¸ í´ë˜ìŠ¤.
- í•µì‹¬ ê¸°ëŠ¥:
  - `StartAttack()`, `EndAttack()`: ê³µê²© ì‹œì‘ ë° ì¢…ë£Œ
  - `CalculateFinalDamage()`: ìµœì¢… ë°ë¯¸ì§€ ê³„ì‚°
  - `PickUp_Implementation()`: ë¬´ê¸° íšë“
  - `ConvertToInventoryItem()`: ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ë³€í™˜
- **ì‚¬ìš© ì¸í„°í˜ì´ìŠ¤:** `IZPickable`, `IZDropable`

------

### **2) ZMeleeWeaponBase (ê·¼ì ‘ ë¬´ê¸°)**

```cpp
class Z1_API AZMeleeWeaponBase : public AZBaseWeapon
{
	GENERATED_BODY()

public:
	AZMeleeWeaponBase();

protected:
	virtual void BeginPlay() override;
	virtual void StartAttack() override;
	virtual void EndAttack() override;
	virtual float CalculateFinalDamage() override;

private:
	void OnWeaponOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                         UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,
                         bool bFromSweep, const FHitResult& SweepResult);

	void OnWeaponHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
                     UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
};
```

- **ì„¤ëª…:** ê·¼ì ‘ ë¬´ê¸° (ë„ë¼, ê²€ ë“±)
- í•µì‹¬ ê¸°ëŠ¥:
  - `OnWeaponOverlap()`, `OnWeaponHit()`: ê³µê²© ì¶©ëŒ ê°ì§€
  - `CalculateFinalDamage()`: ê·¼ì ‘ ë¬´ê¸° ë°ë¯¸ì§€ ê³„ì‚° (í˜/ë¯¼ì²© ë°˜ì˜)

------

### **3) ZRangedWeaponBase (ì›ê±°ë¦¬ ë¬´ê¸°)**

```cpp
class Z1_API AZRangedWeaponBase : public AZBaseWeapon
{
	GENERATED_BODY()

public:
	AZRangedWeaponBase();

	virtual void StartAttack() override;
	virtual void EndAttack() override;

	void MakeShot();
	bool GetTraceData(FVector& TraceStart, FVector& TraceEnd) const;
	bool GetPlayerViewPoint(FVector& ViewLocation, FRotator& ViewRotation) const;

private:
	bool FireInProgress;
	FAmmoData CurrentAmmo;
	FAmmoData DefaultAmmo;
};
```

- **ì„¤ëª…:** ì›ê±°ë¦¬ ë¬´ê¸° (ì´ê¸°ë¥˜)
- í•µì‹¬ ê¸°ëŠ¥:
  - `StartAttack()`, `EndAttack()`: ë°œì‚¬ ì‹œì‘ ë° ì¢…ë£Œ
  - `MakeShot()`: ì´ì•Œ ë°œì‚¬ ì²˜ë¦¬
  - `GetTraceData()`: ì´ì•Œ ê¶¤ì  ë°ì´í„° ê³„ì‚°
  - `GetPlayerViewPoint()`: ì¹´ë©”ë¼ ì‹œì  ê¸°ì¤€ ì‚¬ê²© ë°©í–¥ ê³„ì‚°
- ì¶”ê°€ ìš”ì†Œ:
  - íƒ„ì•½ ì‹œìŠ¤í…œ (`CurrentAmmo`, `DefaultAmmo`)
  - ì¬ì¥ì „ (`ChangeClip()`)

------

## **4. ì½”ë“œ ì˜ˆì œ ë° ì„¤ëª… (Code & Explanation)**

### **ğŸ“Œ ì•„ì´í…œì„ í”½ì—…í•˜ëŠ” ë¡œì§ (AZBaseWeapon)**

```cpp
EInventoryActionResult AZBaseWeapon::PickUp_Implementation(APawn* Player)
{
    AZ1Character* Character = Cast<AZ1Character>(Player);
    if (!IsValid(Character))
    {
        return EInventoryActionResult::Fail;
    }

    UZSpatialInventoryComponent* InvenComp = Character->GetComponentByClass<UZSpatialInventoryComponent>();
    if (!IsValid(InvenComp))
    {
        return EInventoryActionResult::Fail;
    }

    UZWeaponInventoryItem* WeaponInvenItem = Cast<UZWeaponInventoryItem>(ConvertToInventoryItem());
    if (WeaponInvenItem)
    {
        if (InvenComp->TryAddItem(WeaponInvenItem))
        {
            this->Destroy();
            return EInventoryActionResult::Success;
        }
    }

    return EInventoryActionResult::Fail;
}
```

- ì„¤ëª…:
  - `PickUp_Implementation()`ì—ì„œ í”Œë ˆì´ì–´ê°€ ë¬´ê¸°ë¥¼ ì¤ê³ , ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
  - ë¬´ê¸° íšë“ í›„ `Destroy()` í˜¸ì¶œí•˜ì—¬ ì›”ë“œì—ì„œ ì œê±°

------

## **5. ê²°ë¡ **

**ì •ë¦¬ëœ í•µì‹¬ ê°œë…:**

- **ì¸í„°í˜ì´ìŠ¤(`IZPickable`, `IZDropable`, `IZInteractable`, `IZUseable`)**ë¥¼ í†µí•´ ì•„ì´í…œ ë° ë¬´ê¸°ì˜ ê³µí†µ ê¸°ëŠ¥ì„ ì •ì˜
- **ë¬´ê¸° í´ë˜ìŠ¤(`ZBaseWeapon`, `ZMeleeWeaponBase`, `ZRangedWeaponBase`)**ë¥¼ í†µí•´ ë¬´ê¸° íƒ€ì…ë³„ ë™ì‘ êµ¬í˜„





# íƒ€ê²Ÿ ë½ì˜¨ ì‹œìŠ¤í…œ

### **UZTargetLockComponent (íƒ€ê²Ÿ ë½ì˜¨ ì‹œìŠ¤í…œ) ì •ë¦¬**

------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ê°œìš”**

`UZTargetLockComponent`ëŠ” í”Œë ˆì´ì–´ê°€ íŠ¹ì • ëŒ€ìƒ(ì  AI ë“±)ì„ **ë½ì˜¨(Target Lock-On)** í•˜ì—¬ ê³µê²© ì‹œì ì„ ìœ ì§€í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì‹œìŠ¤í…œì´ë‹¤.

- ê¸°ë³¸ ê°œë…:
  - ë½ì˜¨ ê°€ëŠ¥ ëŒ€ìƒ ì°¾ê¸° (ì£¼ë³€ AI íƒìƒ‰)
  - ëŒ€ìƒê³¼ì˜ ê±°ë¦¬ ë° ê°ë„ ì²´í¬
  - ë½ì˜¨ ëŒ€ìƒ ìœ ì§€ ë° í•´ì œ
  - ë½ì˜¨ëœ ëŒ€ìƒ ë°©í–¥ìœ¼ë¡œ ìºë¦­í„° íšŒì „ ë³´ì •

| ë³€ìˆ˜           | ì„¤ëª…                     |
| -------------- | ------------------------ |
| `LockedTarget` | í˜„ì¬ ë½ì˜¨ëœ ëŒ€ìƒ         |
| `LockRange`    | ë½ì˜¨ ê°€ëŠ¥í•œ ìµœëŒ€ ê±°ë¦¬    |
| `LockAngle`    | ë½ì˜¨ ê°€ëŠ¥í•œ ìµœëŒ€ ì‹œì•¼ê°  |
| `InterpSpeed`  | ë½ì˜¨ ëŒ€ìƒ íšŒì „ ë³´ì • ì†ë„ |
| `bLocked`      | í˜„ì¬ ë½ì˜¨ ìƒíƒœ ì—¬ë¶€      |

------

## **2. í•µì‹¬ ê¸°ëŠ¥ ë° êµ¬í˜„ (Core Features & Implementation)**

### **1) ë½ì˜¨ ê¸°ëŠ¥ í† ê¸€ (`ToggleLockOnTarget()`)**

```cpp
void UZTargetLockComponent::ToggleLockOnTarget()
{
	if (IsLocked())
	{
		ReleaseLock();
	}
	else
	{
		FindAndLockTarget();
	}
}
```

- ì„¤ëª…:
  - `IsLocked()` ì—¬ë¶€ì— ë”°ë¼ **ë½ì˜¨ í™œì„±í™” ë˜ëŠ” í•´ì œ**.

------

### **2) ëŒ€ìƒ íƒìƒ‰ ë° ë½ì˜¨ (`FindAndLockTarget()`)**

```cpp
void UZTargetLockComponent::FindAndLockTarget()
{
	TObjectPtr<AActor> Owner = GetOwner();
	if (!Owner) return;

	FVector OwnerLocation = Owner->GetActorLocation();
	TArray<FOverlapResult> OverlapResults;
	FCollisionShape Sphere = FCollisionShape::MakeSphere(LockRange);
	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(Owner);

	bool bHit = GetWorld()->OverlapMultiByChannel(
		OverlapResults,
		OwnerLocation,
		FQuat::Identity,
		ECC_Pawn,
		Sphere,
		QueryParams
	);

	TArray<TObjectPtr<AActor>> CandidateTargets;
	if (bHit)
	{
		for (const FOverlapResult& Result : OverlapResults)
		{
			TObjectPtr<AActor> OverlappedActor = Result.GetActor();
			if (OverlappedActor && OverlappedActor->IsA<AZAICharacter>())
			{
				CandidateTargets.Add(OverlappedActor);
			}
		}
	}

	TObjectPtr<AActor> BestTarget = SelectBestTarget(CandidateTargets);
	if (BestTarget)
	{
		LockedTarget = BestTarget;
		if (AZAICharacter* AICharacter = Cast<AZAICharacter>(LockedTarget))
		{
			AICharacter->ShowLockOnWidget(true);
		}

		bLocked = true;
		SetRotationMode(ERotationMode::TargetLock);
	}
}
```

- ì„¤ëª…:
  1. `OverlapMultiByChannel()`ì„ ì‚¬ìš©í•˜ì—¬ **êµ¬í˜• ì˜ì—­ ë‚´ì— ìˆëŠ” ì  íƒìƒ‰**.
  2. `SelectBestTarget()`ì„ í˜¸ì¶œí•˜ì—¬ ê°€ì¥ ì í•©í•œ ì ì„ ì„ íƒ.
  3. ë½ì˜¨ ëŒ€ìƒì´ í™•ì •ë˜ë©´ `LockedTarget`ì— ì €ì¥ í›„ `bLocked = true`.

------

### **3) ë½ì˜¨ í•´ì œ (`ReleaseLock()`)**

```cpp
void UZTargetLockComponent::ReleaseLock()
{
	if (AZAICharacter* AICharacter = Cast<AZAICharacter>(LockedTarget))
	{
		AICharacter->ShowLockOnWidget(false);
	}

	LockedTarget = nullptr;
	bLocked = false;
	SetRotationMode(ERotationMode::FreeLook);
}
```

- ì„¤ëª…:
  - **UI ì œê±°** (ë½ì˜¨ ì•„ì´ì½˜ ìˆ¨ê¸°ê¸°).
  - ë½ì˜¨ ëŒ€ìƒ ì œê±° (`LockedTarget = nullptr`).
  - íšŒì „ ëª¨ë“œë¥¼ **ììœ  íšŒì „(`FreeLook`)**ìœ¼ë¡œ ë³€ê²½.

------

### **4) íƒ€ê²Ÿ ì„ íƒ ë¡œì§ (`SelectBestTarget()`)**

```cpp
TObjectPtr<AActor> UZTargetLockComponent::SelectBestTarget(const TArray<TObjectPtr<AActor>>& TargetList)
{
	TObjectPtr<AActor> Owner = GetOwner();
	if (!Owner || TargetList.Num() == 0)
	{
		return nullptr;
	}

	TObjectPtr<AActor> BestTarget = nullptr;
	float BestScore = MAX_flt;
	
	for (TObjectPtr<AActor> Candidate : TargetList)
	{
		if (!Candidate->IsA<AZAICharacter>()) continue;
		if (!TargetAngleChecking(Candidate)) continue;

		float Distance = FVector::Dist(Owner->GetActorLocation(), Candidate->GetActorLocation());
		if (TargetDistanceChecking(Candidate, BestScore))
		{
			BestScore = Distance;
			BestTarget = Candidate;
		}
	}

	return BestTarget;
}
```

- ì„¤ëª…:
  1. `TargetAngleChecking()`ì„ í†µí•´ **ì‹œì•¼ê° ë‚´ì˜ ì **ë§Œ ê³ ë ¤.
  2. `TargetDistanceChecking()`ì„ í†µí•´ **ê°€ì¥ ê°€ê¹Œìš´ ì ** ì„ íƒ.

------

### **5) ê±°ë¦¬ ë° ì‹œì•¼ê° ì²´í¬**

#### **ğŸ“Œ ê±°ë¦¬ ì²´í¬ (`TargetDistanceChecking()`)**

```cpp
bool UZTargetLockComponent::TargetDistanceChecking(const TObjectPtr<AActor>& SelectedActor, float BestDistance)
{
	FVector OwnerLocation = GetOwner()->GetActorLocation();
	float CurrentDistance = FVector::Dist(OwnerLocation, SelectedActor->GetActorLocation());

	if (CurrentDistance > BestDistance)
	{
		return false;
	}

	return true;
}
```

- ì„¤ëª…:
  - **ê°€ì¥ ê°€ê¹Œìš´ ëŒ€ìƒë§Œ ì„ íƒ**ë˜ë„ë¡ ê±°ë¦¬ ë¹„êµ.

#### **ğŸ“Œ ì‹œì•¼ê° ì²´í¬ (`TargetAngleChecking()`)**

```cpp
bool UZTargetLockComponent::TargetAngleChecking(const TObjectPtr<AActor>& SelectedActor)
{
	FVector OwnerLocation = GetOwner()->GetActorLocation();
	FVector OwnerForward = GetOwner()->GetActorForwardVector();
	
	FVector DirToCandidate = (SelectedActor->GetActorLocation() - OwnerLocation).GetSafeNormal();
	float DotProduct = FVector::DotProduct(OwnerForward, DirToCandidate);
	float AngleDegrees = FMath::Acos(DotProduct) * (180.f / PI);

	return AngleDegrees <= LockAngle;
}
```

- ì„¤ëª…:
  - `DotProduct`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹œì•¼ê°ì„ ì¸¡ì •.
  - **ì •ë©´ì— ê°€ê¹Œìš´ ì **ë§Œ ë½ì˜¨ ê°€ëŠ¥.

------

### **6) ë½ì˜¨ ëŒ€ìƒ íšŒì „ ë³´ì • (`UpdateTargetingRotation()`)**

```cpp
void UZTargetLockComponent::UpdateTargetingRotation(float DeltaTimeSeconds)
{
	AZ1Character* Character = Cast<AZ1Character>(GetOwner());
	if (!Character || !LockedTarget) return;

	AController* Controller = Character->GetController();
	if (!Controller) return;
	
	FVector CharacterLocation = Character->GetActorLocation();
	FVector TargetLocation = LockedTarget->GetActorLocation();
	TargetLocation.Z -= CameraZValueScale;

	FRotator TargetRotation = UKismetMathLibrary::FindLookAtRotation(CharacterLocation, TargetLocation);
	FRotator CurrentRotation = Character->GetActorRotation();

	FRotator InterpolatedRotation = FMath::RInterpTo(CurrentRotation, TargetRotation, DeltaTimeSeconds, InterpSpeed);
	FRotator NewControlRotation(InterpolatedRotation.Pitch, InterpolatedRotation.Yaw, Character->GetActorRotation().Roll);
	Controller->SetControlRotation(NewControlRotation);
}
```

- ì„¤ëª…:
  1. `FindLookAtRotation()`ì„ ì‚¬ìš©í•˜ì—¬ **í”Œë ˆì´ì–´ê°€ ì ì„ ë°”ë¼ë³´ë„ë¡ íšŒì „**.
  2. `FMath::RInterpTo()`ë¥¼ í†µí•´ ë¶€ë“œëŸ½ê²Œ íšŒì „ ë³´ì •.

------

## **3. ê²°ë¡ **

### **ğŸ”‘ ì£¼ìš” ì„¤ê³„ í¬ì¸íŠ¸**

- **ë½ì˜¨ ëŒ€ìƒ íƒìƒ‰:** `OverlapMultiByChannel()`ì„ ì´ìš©í•˜ì—¬ ì£¼ë³€ ì ì„ ì°¾ìŒ.
- **íƒ€ê²Ÿ ì„ ì • ê¸°ì¤€:** ê°€ì¥ ê°€ê¹Œìš´ ì ì´ë©´ì„œ, ì‹œì•¼ê° ë‚´ì— ìˆëŠ” ëŒ€ìƒ.
- **íšŒì „ ë³´ì •:** `FindLookAtRotation()`ê³¼ `RInterpTo()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¶€ë“œëŸ½ê²Œ íšŒì „.

### **ğŸ› ï¸ ì¶”ê°€ ê°œì„  ê°€ëŠ¥ ì‚¬í•­**

- **ì¹´ë©”ë¼ ì œì–´ ì¶”ê°€:** ë½ì˜¨ ì‹œì ì—ì„œ ì¹´ë©”ë¼ë¥¼ ë” ë™ì ìœ¼ë¡œ ë³€ê²½.
- **íƒ€ê²Ÿ ë³€ê²½ ê¸°ëŠ¥ ì¶”ê°€:** ì—¬ëŸ¬ ê°œì˜ ëŒ€ìƒì´ ìˆì„ ê²½ìš° ë½ì˜¨ ì „í™˜ ê¸°ëŠ¥.





# ê·¼ì ‘ ë¬´ê¸° ì¶©ëŒ ê°ì§€ ì‹œìŠ¤í…œ



### ** ê·¼ì ‘ ë¬´ê¸° íˆíŠ¸ ê°ì§€ ì‹œìŠ¤í…œ ì •ë¦¬**

------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ê°œìš”**

`UZWeaponTraceComponent`ëŠ” **ê·¼ì ‘ ë¬´ê¸° ê³µê²© ì‹œ íˆíŠ¸ ê°ì§€ë¥¼ ìˆ˜í–‰**í•˜ëŠ” **UE5ì˜ Custom Trace System**ì´ë‹¤.

- ê¸°ë³¸ ê°œë…:
  - **íˆíŠ¸ë°•ìŠ¤ ê°ì§€** â†’ AI ì  ìºë¦­í„°ì™€ì˜ ì¶©ëŒ ê°ì§€
  - **Swing Arc ê¸°ë°˜ ì¶©ëŒ ê²€ì‚¬** â†’ ì´ì „ í”„ë ˆì„ê³¼ í˜„ì¬ í”„ë ˆì„ì˜ ë¬´ê¸° ìœ„ì¹˜ë¥¼ ì´ìš©í•˜ì—¬ íƒ€ê²© ì˜ì—­ì„ ê³„ì‚°
  - **ì‚¼ê°í˜• ê¸°ë°˜ ì¶©ëŒ ì²´í¬** â†’ `GenerateCollisionMesh()`ì—ì„œ **íŠ¸ëœì§€ì…˜ ì¤‘ ê²¹ì¹˜ëŠ” ê³µê°„ì„ ê²€ì¶œ**
  - **OverlapMultiByChannel()ì„ í™œìš©í•œ ì¶©ëŒ ì²´í¬** â†’ `ECC_GameTraceChannel2` ì±„ë„ì„ ì‚¬ìš©í•˜ì—¬ ì  ìºë¦­í„°ë¥¼ ê°ì§€

| ë³€ìˆ˜                         | ì„¤ëª…                               |
| ---------------------------- | ---------------------------------- |
| `PrevStartPos`, `PrevEndPos` | ì´ì „ í”„ë ˆì„ì—ì„œì˜ ë¬´ê¸° ìœ„ì¹˜        |
| `SegmentCount`               | ë¬´ê¸° ê¶¤ì ì„ ìƒ˜í”Œë§í•  ì„¸ê·¸ë¨¼íŠ¸ ê°œìˆ˜ |
| `bHasPreviousData`           | ì´ì „ í”„ë ˆì„ ë°ì´í„° ë³´ìœ  ì—¬ë¶€       |
| `bDebugDraw`                 | ë””ë²„ê·¸ìš© ì„  ì¶œë ¥ ì—¬ë¶€              |

------

## **2. í•µì‹¬ ê¸°ëŠ¥ ë° êµ¬í˜„ (Core Features & Implementation)**

### **1) ë¬´ê¸° ì¶©ëŒ ì˜ì—­ ìƒì„± (`GenerateCollisionMesh()`)**

```cpp
void UZWeaponTraceComponent::GenerateCollisionMesh(const FVector& CurrentStart, const FVector& CurrentEnd)
{
	if (!bHasPreviousData)
	{
		PrevStartPos = CurrentStart;
		PrevEndPos = CurrentEnd;
		bHasPreviousData = true;
		return;
	}

	// ì„ í˜• ë³´ê°„ì„ í†µí•œ ì  ìƒì„±
	TArray<FVector> Points;
	for (int32 i = 0; i <= SegmentCount; ++i)
	{
		const float Alpha = static_cast<float>(i) / SegmentCount;
		const FVector PrevPoint = FMath::Lerp(PrevStartPos, PrevEndPos, Alpha);
		const FVector CurrentPoint = FMath::Lerp(CurrentStart, CurrentEnd, Alpha);
		Points.Add(PrevPoint);
		Points.Add(CurrentPoint);
	}

	// ì‚¼ê°í˜• ìƒì„± ë° ì¶©ëŒ ê²€ì‚¬
	for (int32 i = 0; i < Points.Num() - 2; ++i)
	{
		CheckTriangleCollision(Points[i], Points[i + 1], Points[i + 2]);
	}

	// ì´ì „ ë°ì´í„° ì—…ë°ì´íŠ¸
	PrevStartPos = CurrentStart;
	PrevEndPos = CurrentEnd;
}
```

- ì„¤ëª…:
  - **ì´ì „ í”„ë ˆì„(`PrevStartPos`)ê³¼ í˜„ì¬ í”„ë ˆì„(`CurrentStart`)ì˜ ìœ„ì¹˜ë¥¼ ë¹„êµí•˜ì—¬ ì¶©ëŒ ì˜ì—­ì„ ìƒì„±**.
  - **ì„ í˜• ë³´ê°„(`FMath::Lerp()`)ì„ í†µí•´ ìƒ˜í”Œë§ëœ ì ì„ ìƒì„±**.
  - **ìƒ˜í”Œë§ëœ ì ë“¤ì„ ì´ìš©í•´ ì‚¼ê°í˜•ì„ ìƒì„±**í•˜ì—¬ ì¶©ëŒ ì²´í¬.

------

### **2) ì‚¼ê°í˜• ì¶©ëŒ ì²´í¬ (`CheckTriangleCollision()`)**

```cpp
void UZWeaponTraceComponent::CheckTriangleCollision(const FVector& A, const FVector& B, const FVector& C)
{
	UWorld* World = GetWorld();
	if (!World) return;

	// ìƒ˜í”Œë§ í¬ì¸íŠ¸
	const TArray<FVector> SamplePoints = { A, B, C, (A + B) / 2, (B + C) / 2, (C + A) / 2 };

	// íˆíŠ¸ë°•ìŠ¤ ê²€ì¶œ
	FCollisionQueryParams Params;
	Params.AddIgnoredActor(GetOwner());

	for (const FVector& Point : SamplePoints)
	{
		TArray<FOverlapResult> Overlaps;
		if (World->OverlapMultiByChannel(
			Overlaps,
			Point,
			FQuat::Identity,
			ECC_GameTraceChannel2, // íˆíŠ¸ë°•ìŠ¤ ì±„ë„
			FCollisionShape::MakeSphere(15.0f),
			Params))
		{
			if (IsTriangleIntersectingWithHitbox(Overlaps))
			{
				// ë¬´ê¸° ë°ë¯¸ì§€ ì ìš©
			}
		}
	}

	// ë””ë²„ê·¸ ë¼ì¸ ì¶œë ¥
	if (bDebugDraw)
	{
		DrawDebugLine(World, A, B, FColor::Blue, false, 1.0f);
		DrawDebugLine(World, B, C, FColor::Blue, false, 1.0f);
		DrawDebugLine(World, C, A, FColor::Blue, false, 1.0f);
	}
}
```

- ì„¤ëª…:
  - `SamplePoints`ë¥¼ ìƒì„±í•˜ì—¬ íˆíŠ¸ë°•ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸.
  - `OverlapMultiByChannel()`ì„ ì‚¬ìš©í•˜ì—¬ ì¶©ëŒ ê°ì§€.
  - ì¶©ëŒ ê°ì§€ ì‹œ **ë¬´ê¸° ë°ë¯¸ì§€ë¥¼ ì ìš©**í•  ìˆ˜ ìˆë„ë¡ í™•ì¥ ê°€ëŠ¥.

------

### **3) íˆíŠ¸ë°•ìŠ¤ì™€ì˜ ì¶©ëŒ ì—¬ë¶€ ì²´í¬ (`IsTriangleIntersectingWithHitbox()`)**

```cpp
bool UZWeaponTraceComponent::IsTriangleIntersectingWithHitbox(const TArray<FOverlapResult>& OverlapResults)
{
	for (const auto& Overlap : OverlapResults)
	{
		TObjectPtr<AZAICharacter> AICharacter = Cast<AZAICharacter>(Overlap.GetActor());
		if (IsValid(AICharacter))
		{
			TObjectPtr<UCapsuleComponent> HitboxComponent = AICharacter->FindComponentByClass<UCapsuleComponent>();
			if (IsValid(HitboxComponent))
			{
				return true;
			}
		}
	}
	return false;
}
```

- ì„¤ëª…:
  - `OverlapMultiByChannel()`ì„ í†µí•´ ê°ì§€ëœ ê°ì²´ê°€ **AI ìºë¦­í„°ì¸ì§€ í™•ì¸**.
  - **AI ìºë¦­í„°ì˜ íˆíŠ¸ë°•ìŠ¤(`UCapsuleComponent`)ê°€ ìœ íš¨í•œ ê²½ìš° ì¶©ëŒ**ë¡œ íŒë³„.

------

### **4) AZMeleeWeaponBaseì— ì¶”ê°€í•˜ì—¬ ì‚¬ìš©**

```cpp
AZMeleeWeaponBase::AZMeleeWeaponBase()
{
	TraceComponent = CreateDefaultSubobject<UZWeaponTraceComponent>("WeaponTraceComp");
}
```

- ì„¤ëª…:
  - `AZMeleeWeaponBase`ì— **UZWeaponTraceComponentë¥¼ í¬í•¨**í•˜ì—¬ ê·¼ì ‘ ë¬´ê¸° ê³µê²© ì‹œ ì‚¬ìš©.

------

## **3. ê²°ë¡ **

### **ğŸ”‘ ì£¼ìš” ì„¤ê³„ í¬ì¸íŠ¸**

1. **Swing Arc ê¸°ë°˜ ì¶©ëŒ ê°ì§€**
   - **ì´ì „ í”„ë ˆì„ê³¼ í˜„ì¬ í”„ë ˆì„ì˜ ë¬´ê¸° ìœ„ì¹˜ë¥¼ ë³´ê°„í•˜ì—¬ íƒ€ê²© ì˜ì—­ì„ ê³„ì‚°**.
   - **OverlapMultiByChannel()ì„ ì‚¬ìš©í•´ ì ê³¼ì˜ ì¶©ëŒ ì²´í¬**.
2. **ì‚¼ê°í˜• ì¶©ëŒ ê²€ì‚¬ ìµœì í™”**
   - **ì—¬ëŸ¬ ì ì„ ìƒ˜í”Œë§í•˜ì—¬ íˆíŠ¸ë°•ìŠ¤ë¥¼ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸**.
3. **ë””ë²„ê·¸ ê¸°ëŠ¥ ì¶”ê°€ (`bDebugDraw`)**
   - **ë””ë²„ê¹… ì‹œ ì¶©ëŒ ê²€ì‚¬ ì˜ì—­ì„ ì‹œê°ì ìœ¼ë¡œ í™•ì¸ ê°€ëŠ¥**.

### **ğŸš€ í–¥í›„ ê°œì„  ê°€ëŠ¥ ì‚¬í•­**

- **ì• ë‹ˆë©”ì´ì…˜ ê¸°ë°˜ ì¶©ëŒ ê°ì§€ ìµœì í™”**
  - í˜„ì¬ëŠ” `FMath::Lerp()`ë¥¼ ì´ìš©í•œ ë‹¨ìˆœ ë³´ê°„ ë°©ì‹ì„ ì‚¬ìš©í•˜ì§€ë§Œ, ì• ë‹ˆë©”ì´ì…˜ ê³¡ì„ ì„ í™œìš©í•  ìˆ˜ ìˆìŒ.
- **ë‹¤ì¤‘ íƒ€ê²© ê°ì§€ ì¶”ê°€**
  - í˜„ì¬ ì¶©ëŒ ì‹œ í•œ ë²ˆë§Œ ê°ì§€í•˜ì§€ë§Œ, ì—¬ëŸ¬ í”„ë ˆì„ ë™ì•ˆ ê³µê²©ì´ ì§€ì†ë˜ë©´ ë‹¤ì¤‘ íƒ€ê²©ì´ ê°€ëŠ¥í•˜ë„ë¡ ìˆ˜ì •.



![ìŠ¤í¬ë¦°ìƒ· 2025-03-16 231749](C:\Users\junhy\OneDrive\ì‚¬ì§„\Screenshots\ìŠ¤í¬ë¦°ìƒ· 2025-03-16 231749.png) 







# **ìºë¦­í„°ì˜ ë‹¤ì–‘í•œ ì•¡ì…˜ì„ ê´€ë¦¬**í•˜ëŠ” ì‹œìŠ¤í…œ

### **UZActionComponent & UZAction (ì•¡ì…˜ ì‹œìŠ¤í…œ) ì •ë¦¬**

------

## **1. ì•„í‚¤í…ì²˜ ë° ì‹œìŠ¤í…œ ì„¤ê³„ (Architecture & Design)**

### **1) ê°œìš”**

`UZActionComponent`ëŠ” **ìºë¦­í„°ì˜ ë‹¤ì–‘í•œ ì•¡ì…˜(ì˜ˆ: êµ¬ë¥´ê¸°, ê³µê²©, íŠ¹ìˆ˜ ìŠ¤í‚¬ ë“±)ì„ ê´€ë¦¬**í•˜ëŠ” ì‹œìŠ¤í…œì´ë‹¤.
 `UZAction`ì„ ê¸°ë°˜ìœ¼ë¡œ ì—¬ëŸ¬ ê°œì˜ **ì•¡ì…˜ í´ë˜ìŠ¤(ì˜ˆ: UZRollAction)**ë¥¼ ê´€ë¦¬í•˜ë©°, `GameplayTag`ë¥¼ ì´ìš©í•œ íƒœê·¸ ê¸°ë°˜ ì œì–´ ê¸°ëŠ¥ë„ í¬í•¨ëœë‹¤.

- ê¸°ë³¸ ê°œë…:
  - `UZActionComponent`: ì•¡ì…˜ì„ ê´€ë¦¬í•˜ëŠ” **ì»´í¬ë„ŒíŠ¸**.
  - `UZAction`: ê°œë³„ ì•¡ì…˜ì˜ **ì¶”ìƒ í´ë˜ìŠ¤**.
  - `FGameplayTag`: ì•¡ì…˜ ì‹¤í–‰ ì—¬ë¶€ë¥¼ íƒœê·¸ ê¸°ë°˜ìœ¼ë¡œ ì œì–´.
  - `ActionsMap`, `ActionsTagMap`: **ì•¡ì…˜ì„ ì´ë¦„ ë˜ëŠ” íƒœê·¸ë¡œ ê²€ìƒ‰**í•˜ì—¬ ê´€ë¦¬.

### **2) ì£¼ìš” í´ë˜ìŠ¤ êµ¬ì¡°**

| ë³€ìˆ˜                 | ì„¤ëª…                                             |
| -------------------- | ------------------------------------------------ |
| `ActionsMap`         | **FName(ì´ë¦„) ê¸°ë°˜**ìœ¼ë¡œ ë“±ë¡ëœ ì•¡ì…˜ ëª©ë¡        |
| `ActionsTagMap`      | **FGameplayTag(íƒœê·¸) ê¸°ë°˜**ìœ¼ë¡œ ë“±ë¡ëœ ì•¡ì…˜ ëª©ë¡ |
| `ActiveGameplayTags` | í˜„ì¬ í™œì„±í™”ëœ íƒœê·¸ ëª©ë¡                          |
| `bIsRunning`         | í•´ë‹¹ ì•¡ì…˜ì´ ì‹¤í–‰ ì¤‘ì¸ì§€ ì—¬ë¶€                     |
| `bIsComboAction`     | ì½¤ë³´ ì•¡ì…˜ì¸ì§€ ì—¬ë¶€                               |
| `bIsBeUpdate`        | ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸í•´ì•¼ í•˜ëŠ” ì•¡ì…˜ì¸ì§€ ì—¬ë¶€        |

------

## **2. í•µì‹¬ ê¸°ëŠ¥ ë° êµ¬í˜„ (Core Features & Implementation)**

### **1) ì•¡ì…˜ ì¶”ê°€ (`AddAction()`)**

```cpp
void UZActionComponent::AddAction(AActor* Instigator, TSubclassOf<UZAction> ActionClass)
{
	if (!ensure(ActionClass)) return;

	UZAction* NewAction = NewObject<UZAction>(GetOwner(), ActionClass);
	if (IsValid(NewAction))
	{
		NewAction->Initialize(this);
		ActionsMap.Add(NewAction->ActionName, NewAction);
		ActionsTagMap.Add(NewAction->ActivationTag, NewAction);

		// ìë™ ì‹¤í–‰ ì•¡ì…˜ì˜ ê²½ìš° ì¦‰ì‹œ ì‹œì‘
		if (NewAction->bAutoStart && NewAction->CanStartAction(GetOwner()))
		{
			NewAction->StartAction(Instigator);
		}
	}
}
```

- ì„¤ëª…:
  - `UZAction` í´ë˜ìŠ¤ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì•¡ì…˜ì„ ìƒì„±í•˜ê³  **ActionsMapê³¼ ActionsTagMapì— ì¶”ê°€**.
  - `bAutoStart`ê°€ `true`ë©´ ìë™ ì‹¤í–‰.

------

### **2) ì•¡ì…˜ ì‹œì‘ (`StartActionByName()`, `StartActionByTag()`)**

```cpp
bool UZActionComponent::StartActionByName(AActor* Instigator, FName ActionName)
{
 	if (!ActionsMap.Contains(ActionName)) return false;

	UZAction* FoundAction = ActionsMap.FindRef(ActionName);
	if (!IsValid(FoundAction) || !FoundAction->CanStartAction(GetOwner())) return false;

	FoundAction->StartAction(Instigator);
	return true;
}
bool UZActionComponent::StartActionByTag(AActor* Instigator, FGameplayTag ActionTag)
{
	if (!ActionsTagMap.Contains(ActionTag)) return false;

	UZAction* FoundAction = ActionsTagMap.FindRef(ActionTag);
	if (!IsValid(FoundAction) || !FoundAction->CanStartAction(GetOwner())) return false;

	FoundAction->StartAction(Instigator);
	return true;
}
```

- ì„¤ëª…:
  - `FName` ë˜ëŠ” `FGameplayTag`ë¡œ ì•¡ì…˜ì„ ê²€ìƒ‰í•˜ì—¬ ì‹¤í–‰.
  - ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ `CanStartAction()`ìœ¼ë¡œ í™•ì¸ í›„ `StartAction()` í˜¸ì¶œ.

------

### **3) ì•¡ì…˜ ì¢…ë£Œ (`StopActionByName()`, `StopActionByTag()`)**

```cpp
bool UZActionComponent::StopActionByName(AActor* Instigator, FName ActionName)
{
	if (!ActionsMap.Contains(ActionName)) return false;

	UZAction* FoundAction = ActionsMap.FindRef(ActionName);
	if (!IsValid(FoundAction) || !FoundAction->IsRunning()) return false;

	FoundAction->StopAction(Instigator);
	return true;
}
bool UZActionComponent::StopActionByTag(AActor* Instigator, FGameplayTag ActionTag)
{
	if (!ActionsTagMap.Contains(ActionTag)) return false;

	UZAction* FoundAction = ActionsTagMap.FindRef(ActionTag);
	if (!IsValid(FoundAction) || !FoundAction->IsRunning()) return false;

	FoundAction->StopAction(Instigator);
	return true;
}
```

- ì„¤ëª…:
  - `IsRunning()` ì—¬ë¶€ë¥¼ í™•ì¸ í›„ `StopAction()` í˜¸ì¶œ.

------

### **4) ì•¡ì…˜ ì‹¤í–‰ ì—¬ë¶€ ì²´í¬ (`CanStartAction()`)**

```cpp
bool UZAction::CanStartAction(AActor* Instigator)
{
	UZActionComponent* Comp = GetOwningComponent();
	if (Comp->ActiveGameplayTags.HasAny(BlockedTags)) return false;

	if (bIsComboAction) return true;
	if (bIsRunning) return false;

	return true;
}
```

- ì„¤ëª…:
  - `BlockedTags`ì— í¬í•¨ëœ íƒœê·¸ê°€ ìˆìœ¼ë©´ ì‹¤í–‰ ë¶ˆê°€.
  - `bIsComboAction`ì´ `true`ë©´ ì‹¤í–‰ ê°€ëŠ¥.
  - ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´ ì‹¤í–‰ ë¶ˆê°€.

------

### **5) ì•¡ì…˜ ì‹¤í–‰ (`StartAction()`)**

```cpp
void UZAction::StartAction(AActor* Instigator)
{
	UE_LOG(LogTemp, Log, TEXT("Running: %s"), *GetNameSafe(Instigator));
	bIsRunning = true;

	UZActionComponent* Comp = GetOwningComponent();
	Comp->ActiveGameplayTags.AppendTags(GrantsTags);

	Comp->OnActionStarted.Broadcast(Comp, this);
}
```

- ì„¤ëª…:
  - `bIsRunning`ì„ `true`ë¡œ ì„¤ì •í•˜ê³  `ActiveGameplayTags`ì— ì¶”ê°€.

------

### **6) ì•¡ì…˜ ì¤‘ì§€ (`StopAction()`)**

```cpp
void UZAction::StopAction(AActor* Instigator)
{
	UE_LOG(LogTemp, Log, TEXT("Running: %s"), *GetNameSafe(Instigator));
	bIsRunning = false;

	UZActionComponent* Comp = GetOwningComponent();
	Comp->ActiveGameplayTags.RemoveTags(GrantsTags);

	Comp->OnActionStopped.Broadcast(Comp, this);
}
```

- ì„¤ëª…:
  - `bIsRunning`ì„ `false`ë¡œ ì„¤ì •í•˜ê³  `ActiveGameplayTags`ì—ì„œ ì œê±°.

------

### **7) ì•¡ì…˜ ì—…ë°ì´íŠ¸ (`TickComponent()`)**

```cpp
void UZActionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	FString DebugMsg = GetNameSafe(GetOwner()) + " : " + ActiveGameplayTags.ToStringSimple();
	GEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::White, DebugMsg);

	for (const auto& ActionTuple : ActionsTagMap)
	{
		if (const TObjectPtr<UZAction>& Action = ActionTuple.Value)
		{
			if (Action->IsBeUpdated())
			{
				Action->UpdateAction(GetOwner(), DeltaTime);
			}
		}
	}
}
```

- ì„¤ëª…:
  - `ActionsTagMap`ì„ ìˆœíšŒí•˜ë©° `bIsBeUpdate == true`ì¸ ì•¡ì…˜ì„ ì—…ë°ì´íŠ¸.

------

## **3. ê²°ë¡ **

### **ğŸ”‘ ì£¼ìš” ì„¤ê³„ í¬ì¸íŠ¸**

1. **ì•¡ì…˜ ê´€ë¦¬ ë° íƒœê·¸ ì‹œìŠ¤í…œ í†µí•©**
   - `FName` ë° `FGameplayTag`ì„ ê¸°ë°˜ìœ¼ë¡œ ì•¡ì…˜ì„ **ì‰½ê²Œ ì¶”ê°€, ì œê±°, ì‹¤í–‰**í•  ìˆ˜ ìˆìŒ.
   - `ActiveGameplayTags`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•¡ì…˜ ì‹¤í–‰ ì—¬ë¶€ë¥¼ íƒœê·¸ ê¸°ë°˜ìœ¼ë¡œ ì œì–´.
2. **ë„¤íŠ¸ì›Œí¬ í™•ì¥ ê°€ëŠ¥**
   - `ServerStartAction()`, `ServerStopAction()`ì„ ì¶”ê°€í•˜ë©´ **ë©€í‹°í”Œë ˆì´ì–´ ì§€ì› ê°€ëŠ¥**.
3. **ì•¡ì…˜ ìë™ ì‹¤í–‰ ê¸°ëŠ¥**
   - `bAutoStart`ê°€ `true`ë©´ ìë™ ì‹¤í–‰.

