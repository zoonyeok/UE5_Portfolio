# Actioncomponent (GAS)

아래는 **Action System**(UZActionComponent 중심)과 관련된 내용을 포트폴리오 기술문서 형식으로 정리한 예시입니다. 실제 프로젝트 환경과 요구 사항에 맞추어 보완하시면 좋겠습니다.

------

# Action System: UZActionComponent 중심 기술문서

## 1. 개요

이 문서는 **언리얼 엔진** 프로젝트에서 **GameplayTags**와 **컴포넌트 기반 아키텍처**를 활용해 다수의 액션(공격, 이동 특수 동작, 스킬 등)을 유연하게 관리하기 위한 **Action System**에 대한 구조와 동작 방식을 정리한 기술문서입니다.

## 2. 시스템 구조

### 2.1 컴포넌트 기반 아키텍처

- **AZ1Character**와 같은 캐릭터 클래스에 여러 기능성 컴포넌트(`UZActionComponent`, `UZInteractComponent` 등)을 부착하여, 각 기능을 모듈식으로 분리했습니다.
- **UZActionComponent**는 액션(예: 콤보 공격, 구르기, 특수 스킬)을 관리하고 실행·중지·업데이트 등의 로직을 담당합니다.

### 2.2 GameplayTags 활용

- 액션들은 태그(예: `Action.Attack.LCombo`, `Action.Movement.Jumping`)로 구분되며, 액션 실행 시 **BlockedTags**와 **GrantsTags**를 바탕으로 충돌 방지(예: 구르기 중 공격 불가)나 부가 상태 부여 등을 수행할 수 있습니다.
- Unreal의 **FGameplayTagContainer**를 활용해 액션 간 조건 관계를 직관적으로 관리합니다.

### 2.3 입력 처리 (Enhanced Input 연동)

- 캐릭터가 키 입력을 받으면, `AZ1Character` 클래스 내에서 액션 관련 함수를 호출(`StartActionByTag` 등)합니다.
- **액션 실행 → 태그 확인 → 내부 로직 수행**의 간단하고 직관적인 플로우로 구성이 됩니다.

------

## 3. 주요 클래스

### 3.1 AZ1Character

- **역할**: 플레이어 캐릭터 또는 NPC의 베이스 클래스.

- 주요 기능

  :

  - 이동, 회전, 카메라 컨트롤 등 기본 캐릭터 기능.
  - **UZActionComponent**와 **UZInteractComponent**(등 다른 컴포넌트들) 소유.
  - 입력 바인딩 후 `ActionComp->StartActionByTag(...)` 등을 통해 액션 실행.

### 3.2 UZActionComponent

- **역할**: 액션 관련 로직의 핵심 관리 컴포넌트.

- 핵심 메서드

  :

  - `StartActionByTag(FGameplayTag ActionTag)`: 특정 태그의 액션 실행 시도.
  - `StopActionByTag(FGameplayTag ActionTag)`: 특정 태그의 액션 중지.
  - `CanStartAction(UZAction* Action)`: BlockedTags 검사 등 실행 가능 여부 판단.
  - `ProcessComboCommand()`: 콤보 입력이 들어올 때 후속 액션(다음 콤보 단계) 처리를 담당.

- 특징

  :

  - 여러 `UZAction` 인스턴스를 소유하고, 각 액션의 생명주기(시작, 중지, 업데이트)를 관리.
  - 액션 시작 시 **GrantsTags**가 추가되고, **BlockedTags**가 걸려 있는 액션은 실행이 불가능하도록 제어 가능.

### 3.3 UZAction

- **역할**: 액션(공격, 구르기, 스킬, 상호작용 등)에 대한 추상 클래스.

- 주요 메서드

  :

  - `StartAction()`, `StopAction()`: 액션 실행/중지 시점 로직 처리.
  - `TickAction(float DeltaTime)`: 액션 진행 중 매 프레임마다 로직이 필요하다면 사용.
  - `CanStartAction_Implementation(...)`: 액션 실행 가능 여부를 최종적으로 판단(태그 충돌 등).
  - `ProcessComboCommand()`: 콤보 입력 처리 로직.

- 주요 멤버

  :

  - `ActionName`, `BlockedTags`, `GrantsTags`.
  - `bIsRunning`: 현재 액션 실행 여부를 나타내는 플래그.

### 3.4 UZInteractComponent

- **역할**: 오브젝트 상호작용(문 열기, 아이템 획득 등)에 특화된 컴포넌트.
- **비교 포인트**: 액션과 별도로, 특정 타겟 액터를 찾고 상호작용(라인 트레이스, UI 표시 등)을 수행.

------

## 4. 실행 흐름 예시 (콤보 공격)

1. 입력 이벤트 발생
   - 플레이어가 마우스 좌클릭(또는 키보드 특정 키) 입력.
   - `AZ1Character::LComboAttackStart()` 호출.
2. 액션 실행 요청
   - `ActionComp->StartActionByTag(FGameplayTag::RequestGameplayTag("Action.Attack.LCombo"))`.
3. 태그 검사 & 액션 찾기
   - `UZActionComponent`가 내부에서 `"Action.Attack.LCombo"` 태그를 가진 `UZAction`(예: `ULComboAction`)을 검색.
   - `CanStartAction()`을 통해 BlockedTags 등이 있는지 확인.
4. 액션 시작
   - 조건 충족 시, `ULComboAction->StartAction()` 호출 → 애니메이션 재생, 대미지 판정 준비 등.
5. 콤보 입력 처리
   - 액션이 진행 중 추가 입력이 들어오면, `ProcessComboCommand()`를 호출하여 다음 콤보 단계로 연결.

------

## 5. 주요 특징 및 확장성

1. **모듈식 액션 추가**
   - 새 스킬/액션을 구현하려면 `UZAction`을 상속받아 필요한 로직만 작성하면 됩니다.
   - `UZActionComponent`를 통해 액션 목록에 등록하면, 곧바로 태그 기반 실행이 가능합니다.
2. **태그 기반 차단 및 부여**
   - `BlockedTags`, `GrantsTags`로 액션 간 실행 조건을 직관적으로 제어할 수 있습니다.
   - 예: "구르기(Action.Movement.Roll)"가 실행 중일 때는 "공격(Action.Attack.*)" 태그를 가진 액션을 차단.
3. **Enhanced Input과 결합**
   - 입력 리소스 변경 시에도 `AZ1Character`의 입력 함수와 `UZActionComponent` 간 단순 연결 구조로 유연하게 대처 가능.
4. **Data-Driven 구조**
   - 필요 시 DataTable 또는 JSON 등을 통해 액션 속성(타이밍, 애니메이션, 대미지 등)을 외부에서 로드하여 확장성과 유지보수성을 높일 수 있음.

------

## 6. UML 다이어그램 (간단 버전)

```
         +----------------------+
         |      AZ1Character   |
         |----------------------|
         | - ActionComp         |
         | - InteractComp       |
         +----------+-----------+
                    |
                    v (owns)
    +------------------------------+
    |        UZActionComponent    |
    |------------------------------|
    | - Actions (list/array)      |
    |------------------------------|
    | + StartActionByTag(tag)     |
    | + StopActionByTag(tag)      |
    | + ProcessComboCommand(...)  |
    +--------------+---------------+
                   | (has many)
                   v
        +-------------------+
        |     UZAction     |
        |-------------------|
        | - ActionName      |
        | - BlockedTags     |
        | - GrantsTags      |
        | - bIsRunning      |
        +-------------------+
        | + StartAction()   |
        | + StopAction()    |
        | + CanStartAction()|
        | + ProcessComboCmd()|
        +-------------------+

         +----------------------+
         | UZInteractComponent |
         +----------------------+
         | (handles items, etc)|
         +----------------------+
```

------

## 7. 예시 코드

### 7.1 AZ1Character.cpp

```cpp
void AZ1Character::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    Super::SetupPlayerInputComponent(PlayerInputComponent);

    // Enhanced Input 바인딩 예시
    PlayerInputComponent->BindAction("LComboAttack", IE_Pressed, this, &AZ1Character::LComboAttackStart);
}

void AZ1Character::LComboAttackStart()
{
    if (ActionComp)
    {
        ActionComp->StartActionByTag(FGameplayTag::RequestGameplayTag(FName("Action.Attack.LCombo")));
    }
}
```

### 7.2 UZActionComponent.cpp

```cpp
void UZActionComponent::StartActionByTag(FGameplayTag ActionTag)
{
    UZAction* FoundAction = FindActionByTag(ActionTag);
    
    if (FoundAction && CanStartAction(FoundAction))
    {
        FoundAction->StartAction();
    }
    else
    {
        // 이미 실행 중인 액션 등 콤보 처리
        if (FoundAction && FoundAction->bIsRunning)
        {
            FoundAction->ProcessComboCommand();
        }
    }
}

bool UZActionComponent::CanStartAction(UZAction* Action)
{
    // BlockedTags 확인
    if (HasAnyMatchingGameplayTags(Action->BlockedTags))
    {
        return false;
    }
    return true;
}

UZAction* UZActionComponent::FindActionByTag(FGameplayTag ActionTag)
{
    // 간단 예시: 배열 내 액션 탐색
    for (UZAction* Action : Actions)
    {
        if (Action && Action->GrantsTags.HasTag(ActionTag))
        {
            return Action;
        }
    }
    return nullptr;
}
```

### 7.3 UZAction.h

```cpp
UCLASS(Abstract, Blueprintable)
class YOURGAME_API UZAction : public UObject
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintCallable)
    virtual void StartAction()
    {
        bIsRunning = true;
        // GrantsTags 적용, 애니메이션 재생 등
    }

    UFUNCTION(BlueprintCallable)
    virtual void StopAction()
    {
        bIsRunning = false;
        // 태그 해제, 리소스 정리 등
    }

    UFUNCTION(BlueprintNativeEvent)
    bool CanStartAction(UZActionComponent* Comp) const;

    virtual bool CanStartAction_Implementation(UZActionComponent* Comp) const
    {
        // 기본 태그 충돌 체크
        return !Comp->HasAnyMatchingGameplayTags(BlockedTags);
    }

    UFUNCTION(BlueprintCallable)
    virtual void ProcessComboCommand()
    {
        // 콤보 진행 로직
    }

public:
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    FName ActionName;
    
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    FGameplayTagContainer BlockedTags;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    FGameplayTagContainer GrantsTags;

    bool bIsRunning = false;
};
```

------



# 인벤토리 시스템



### 1. 개요

본 문서는 Unreal Engine 5를 활용하여 개발된 게임 내 상호작용 및 공간 인벤토리 시스템의 구조와 구현 방식을 설명합니다. 캐릭터가 아이템을 획득하고, 인벤토리에서 관리하며, 장비를 착용하거나 주변 환경과 상호작용할 수 있도록 구성되었습니다.

------

### 2. 시스템 구성 및 역할

#### 2.1 상호작용 시스템 (`UZInteractComponent`)

- **기능:** 캐릭터 주변의 상호작용 가능한 아이템 및 객체를 감지하고 관리합니다.
- 구현 특징:
  - 라인 트레이스 및 구체형 스윕으로 아이템 탐색
  - 캐릭터 시야 및 거리 기반 상호작용 가능 여부 판단
  - 입력에 따라 즉시 또는 일정 시간 지속된 후 상호작용 처리
  - 상호작용 대상의 UI 위젯과 연동된 포커스 및 상호작용 시작/종료 관리

#### 2.2 공간 인벤토리 시스템 (`UZSpatialInventoryComponent`)

- **기능:** 아이템을 그리드 기반으로 배치하고 관리하는 공간 인벤토리 기능을 제공합니다.
- 구현 특징:
  - 아이템 추가, 제거, 위치 교환, 배치 가능 여부 확인
  - 그리드 셀의 점유 상태를 실시간으로 업데이트하고 복제(replication)를 통한 네트워크 지원
  - 아이템을 드래그 앤 드롭 방식으로 관리하고, 그리드 상 아이템 배치 시 경계 및 겹침 체크

#### 2.3 장비 관리 시스템 (`UZEquipmentManagerComponent`)

- **기능:** 캐릭터의 장착 아이템 상태를 관리하고 애니메이션과 연동하여 시각적 변화를 처리합니다.
- 구현 특징:
  - 슬롯 기반 아이템 장착 및 해제 관리
  - 장착 시 캐릭터의 애니메이션 상태 업데이트 및 몽타주 재생
  - 장비 교체 및 해제 시 애니메이션 종료와 연동한 상태 처리

------

### 3. 핵심 기능 흐름

- **상호작용**
  - 캐릭터 입력(E 키) → `UZInteractComponent`가 상호작용 가능 객체 탐색 → 객체가 인터페이스 구현(`IZInteractable`, `IZPickable`) 여부 체크 → 상호작용 시작 및 종료 처리 → 아이템 획득 또는 환경 객체와의 상호작용 이벤트 발생
- **아이템 관리**
  - 아이템 획득 → `UZSpatialInventoryComponent`의 공간 인벤토리에 배치 → 인벤토리 UI에서 아이템 드래그 앤 드롭 지원 → 그리드 배치 가능 여부 체크 → 아이템 배치, 제거, 위치 교환 관리
- **장비 착용**
  - 인벤토리에서 아이템 선택 → `UZEquipmentManagerComponent`가 아이템 착용 관리 → 캐릭터 능력치 업데이트 → 장착에 따른 캐릭터 애니메이션 및 상태 변경

------

### 4. 시스템 UML 클래스 다이어그램

```plaintext
+----------------------+                +---------------------------------+
| AZ1Character         | ◄─────────────►| UZInteractComponent             |
+----------------------+                +---------------------------------+
| - Components         |                | - InteractionData               |
| + Move(), Attack()   |                | + PerformInteractionCheck()     |
| + Interact()         |                | + BeginInteract(), EndInteract()|
+----------------------+                +---------------------------------+
       │
       ▼
+------------------------------+
| UZSpatialInventoryComponent  |
+------------------------------+
| - GridCells, SlotOccupied    |
| + AddItem(), RemoveItem()    |
| + SwapItems(), CanPlaceItem()|
+------------------------------+
       │
       ▼
+------------------------------+
| UZEquipmentManagerComponent  |
+------------------------------+
| - EquippedInventoryItems     |
| + EquipItem(), UnEquipItem() |
+------------------------------+
```

------



## 코드



------

### 1. 상호작용 대상 탐색 (`UZInteractComponent::PerformInteractionCheck`)

-  시야 및 거리 기반 아이템 탐지, 인터페이스를 활용한 객체 구분 및 반응성 높은 상호작용 로직을 보여줍니다.

```cpp
void UZInteractComponent::PerformInteractionCheck()
{
    FVector EyesLoc;
    FRotator EyesRot;
    MyOwner->GetActorEyesViewPoint(EyesLoc, EyesRot);

    FVector TraceStart = EyesLoc;
    FVector TraceEnd = (EyesRot.Vector() * TraceDistance) + TraceStart;

    TArray<FHitResult> Hits;
    FCollisionShape Shape = FCollisionShape::MakeSphere(TraceRadius);

    bool bBlockingHit = GetWorld()->SweepMultiByObjectType(Hits, TraceStart, TraceEnd, FQuat::Identity, ObjectQueryParams, Shape);

    for (FHitResult& Hit : Hits)
    {
        AZWorldItem* HitActor = Cast<AZWorldItem>(Hit.GetActor());
        if (IsValid(HitActor))
        {
            if (UWorldItemWidgetComponent* WorldItemComponent = HitActor->FindComponentByClass<UWorldItemWidgetComponent>())
            {
                FoundNewInteractable(WorldItemComponent, HitActor);
                return;
            }
        }
    }
    CouldntFindInteractable();
}
```

------

### 2. 공간 인벤토리 아이템 추가 및 교환 (`UZSpatialInventoryComponent::AddItem`, `SwapItems`)

-  아이템을 그리드에 배치 및 교환하는 핵심 로직이며, 공간 인벤토리 시스템의 중요한 설계 및 관리 원리를 나타냅니다.

```cpp
bool UZSpatialInventoryComponent::AddItem(UZInventoryItem* NewItem, FVector2D StartPosition, bool bBroadcast)
{
    if (!CanPlaceItem(StartPosition, NewItem->GetGridSize()))
        return false;

    for (int32 Y = StartPosition.Y; Y < StartPosition.Y + NewItem->GetGridSize().Y; ++Y)
    {
        for (int32 X = StartPosition.X; X < StartPosition.X + NewItem->GetGridSize().X; ++X)
        {
            int32 Index = GetCellIndex(X, Y);
            GridCells[Index] = NewItem;
            SlotOccupied[Index] = true;
        }
    }

    if (bBroadcast && OnInventoryChanged.IsBound())
        OnInventoryChanged.Broadcast();

    return true;
}

void UZSpatialInventoryComponent::SwapItems(UZInventoryItem* ItemInGrid, UZInventoryItem* DroppedItem, FIntPoint DropPosition)
{
    FIntPoint ItemInGridPosition = FindItemPosition(ItemInGrid);
    RemoveItemByGridPosition(ItemInGridPosition, false);

    AddItem(DroppedItem, FVector2D(DropPosition), false);

    if (OnInventoryChanged.IsBound())
        OnInventoryChanged.Broadcast();
}
```

------

### 3. 아이템 드래그 앤 드롭 로직 (`UZInventoryItemWidget::StartDragging`, `StopDragging`)

- UI 상에서 직관적인 드래그 앤 드롭 방식을 구현한 코드로, 사용성 및 UI/UX 고려 능력을 나타냅니다.
- <img src="C:\Users\junhy\AppData\Roaming\Typora\typora-user-images\image-20250316233629856.png" alt="image-20250316233629856" style="zoom:50%;" /> 

```cpp
void UZInventoryItemWidget::StartDragging(const FVector2D& MousePosition)
{
    bIsDragging = true;
    this->RemoveFromParent();
    SetPositionInViewport(MousePosition - (GetDesiredSize() * 0.5f), true);
    AddToViewport();
}

bool UZInventoryItemWidget::StopDragging(const FPointerEvent& InMouseEvent)
{
    FVector2D MousePosition = InMouseEvent.GetScreenSpacePosition();
    auto DropTargets = SpacialInventoryWidget->GetDropTargets();

    for (auto& DropTarget : DropTargets)
    {
        if (DropTarget->HandleDropItem(this, MousePosition))
        {
            bIsDragging = false;
            return true;
        }
    }
    return false;
}
```

------

### 4. 아이템 장착 및 애니메이션 연동 (`UZEquipmentManagerComponent::EquipItem`)

- 아이템 장착 시 애니메이션 및 캐릭터 상태 변화를 명확히 관리하여, 게임 내 장비 시스템 설계 및 구현 역량을 보여줍니다.

  

```cpp
bool UZEquipmentManagerComponent::EquipItem(EItemSlotType SlotType, const TObjectPtr<UZInventoryItem>& Item)
{
    if (!IsValid(Item) || EquippedInventoryItems.Contains(SlotType))
        return false;

    TObjectPtr<AZWorldItem> WorldItem = EquipItemBySlotType(SlotType, Item);
    if (auto Weapon = Cast<AZBaseWeapon>(WorldItem))
    {
        if (auto AnimInstance = Cast<UZAnimInstance>(OwnerCharacter->GetMesh()->GetAnimInstance()))
        {
            AnimInstance->SetAnimationLayerByWeapon(Weapon->GetArmedCharacterAnimLayer());
            AnimInstance->PlayAnimMontage(Weapon->GetEquipAnimMontage());

            EquippedInventoryItems.Add(SlotType, Item);
            EquippedWorldItems.Add(SlotType, WorldItem);
            OnEquippedItems.Broadcast(SlotType, Item);
            return true;
        }
    }
    return false;
}
```

------

### 5. 동적 UI 그리드 렌더링 (`UZInventoryGridWidget::NativePaint`)

- 인벤토리 그리드 UI의 동적 렌더링을 통해, UI의 실시간 갱신 및 렌더링 능력을 효과적으로 표현합니다.

```cpp
int32 UZInventoryGridWidget::NativePaint(const FPaintArgs& Args, const FGeometry& AllottedGeometry,
                                         const FSlateRect& MyCullingRect, FSlateWindowElementList& OutDrawElements,
                                         int32 LayerId, const FWidgetStyle& InWidgetStyle, bool bParentEnabled) const
{
    FVector2D TopLeft = GridBorder->GetCachedGeometry().GetLocalPositionAtCoordinates(FVector2D(0, 0));
    for (const FLine& Line : GridLines)
    {
        FVector2D Start = Line.Start + TopLeft;
        FVector2D End = Line.End + TopLeft;

        TArray<FVector2D> LinePoints = {Start, End};
        UWidgetBlueprintLibrary::DrawLines(FPaintContext(AllottedGeometry, MyCullingRect, OutDrawElements, LayerId,
                                                         InWidgetStyle, bParentEnabled), LinePoints, GridLineColor, true, 2.0f);
    }
    return LayerId + 1;
}
```

------





### 사진 

### <img src="C:\Users\junhy\OneDrive\사진\Screenshots\스크린샷 2025-03-16 231452.png" alt="스크린샷 2025-03-16 231452" style="zoom:50%;" />

 

<img src="C:\Users\junhy\OneDrive\사진\Screenshots\스크린샷 2025-03-16 231558.png" alt="스크린샷 2025-03-16 231558" style="zoom:50%;" /> 



<img src="C:\Users\junhy\OneDrive\사진\Screenshots\스크린샷 2025-03-16 231835.png" alt="스크린샷 2025-03-16 231835" style="zoom:50%;" /> 

# Item 설계

- WorldItem
- InventoryItem

- Pickable
- Useable
- Dropable
- Interactable

- WorldItem

  - Weapon

    - MeleeWeapon
    - RangedWeapon

    

# TargetLock

- 가까운 AIPawn 거리 계산해서 타겟으로 고정





# WeaponTrace



- 무기의 궤적을 따라 trace해서 충돌판정

  



















